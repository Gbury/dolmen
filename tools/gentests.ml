
(* This file is free software, part of dolmen. See file "LICENSE" for more information *)


(* Helper functions *)
(* ************************************************************************* *)

let incr_output_of_problem file =
  Filename.chop_extension file ^ ".incremental"

let full_output_of_problem file =
  Filename.chop_extension file ^ ".full"

let expected_of_problem file =
  Filename.chop_extension file ^ ".expected"

let supports_incremental file =
  match Filename.extension file with
  | ".ae" -> false
  | _ -> true

let is_a_pb file =
  match Filename.extension file with
  | ".ae"
  | ".cnf"
  | ".icnf"
  | ".smt2"
  | ".psmt2"
  | ".p"
  | ".zf"
    -> true
  | _
    -> false


(* Unix helper functions *)
(* ************************************************************************* *)

(* touch the file *)
let touch file contents =
  if Sys.file_exists file then
    true
  else
    let ch = open_out file in
    output_string ch contents;
    let () = close_out ch in
    false

(* read a file and print it out *)
let cat fmt file =
  let ch = open_in file in
  try while true do
      let s = input_line ch in
      Format.fprintf fmt "%s@\n" s
    done
  with End_of_file ->
    Format.fprintf fmt "@."


(* Scan a folder *)
let scan_folder path =
  let handle = Unix.opendir path in
  let rec aux files folders h =
    match Unix.readdir h with
    | exception End_of_file ->
      Unix.closedir h;
      List.sort String.compare files,
      List.sort String.compare folders
    | "." | ".." ->
      aux files folders h
    | s ->
      let f = Filename.concat path s in
      let stat = Unix.stat f in
      begin match stat.st_kind with
        | Unix.S_REG -> aux (s :: files) folders h
        | Unix.S_DIR -> aux files (s :: folders) h
        | _ -> aux files folders h
      end
  in
  aux [] [] handle


(* Base stanza *)
(* ************************************************************************* *)

let rec pp_exit_codes fmt = function
  | [] -> assert false
  | [x] -> Format.fprintf fmt "%d" x
  | x :: r -> Format.fprintf fmt "(or %d %a)" x pp_exit_codes r

let test_stanza_aux mode fmt (res_file, pb_file, exit_codes, expected_file) =
  Format.fprintf fmt {|
(rule
  (target  %s)
  (deps    %s)
  (package dolmen_bin)
  (action (chdir %%{workspace_root}
           (with-outputs-to %%{target}
            (with-accepted-exit-codes %a
             (run dolmen --mode=%s --color=false %%{deps} %%{read-lines:flags.dune}))))))
(rule
  (alias runtest)
  (action (diff %s %s)))
|}
    res_file pb_file
    pp_exit_codes exit_codes
    mode expected_file res_file

let test_stanza_incr fmt ((_, pb_file, _, _) as data) =
  if not (supports_incremental pb_file) then ()
  else Format.fprintf fmt "; Incremental test@\n%a@\n" (test_stanza_aux "incremental") data

let test_stanza_full fmt data =
  Format.fprintf fmt "; Full mode test@\n%a@\n" (test_stanza_aux "full") data

let test_stanza fmt (exit_codes, pb_file) =
  let incr_file = incr_output_of_problem pb_file in
  let full_file = full_output_of_problem pb_file in
  let expected_file = expected_of_problem pb_file in
  Format.fprintf fmt "; Test for %s@\n%a%a@\n" pb_file
    test_stanza_incr (incr_file, pb_file, exit_codes, expected_file)
    test_stanza_full (full_file, pb_file, exit_codes, expected_file)



(* Generating a test case *)
(* ************************************************************************* *)


let is_empty_or_create file contents =
  if touch file contents then
    let ch = open_in file in
    try
      let _ = input_char ch in
      false
    with End_of_file ->
      true
  else
    true

let check_expect_file path =
  let default_expect_contents = "run 'make test-promote' to update this file" in
  is_empty_or_create path default_expect_contents

let gen_test fmt path pb =
  let expected_file = Filename.concat path (expected_of_problem pb) in
  let exit_codes = if check_expect_file expected_file then [0] else [0; 1] in
  test_stanza fmt (exit_codes, pb)


(* Generating tests for a folder and its files *)
(* ************************************************************************* *)

let is_not_empty_or_delete file =
  if Sys.file_exists file then
    let ch = open_in file in
    try
      let _ = input_char ch in
      true
    with End_of_file ->
      let () = Sys.remove file in
      false
  else
    false


let gen_tests path files =
  match List.filter is_a_pb files with
  | [] -> ()
  | pbs ->
    let _ = touch (Filename.concat path "flags.dune") "" in
    let ch = open_out (Filename.concat path "dune") in
    let fmt = Format.formatter_of_out_channel ch in
    let () = Format.fprintf fmt "; File auto-generated by gentests.ml@\n" in
    let () =
      let templ = Filename.concat path "dune.templ" in
      if is_not_empty_or_delete templ then begin
        Format.fprintf fmt
          "; Template begin@\n%a@\n; Template end@\n@\n"
          cat templ
      end
    in
    let () = Format.fprintf fmt "; Auto-generated part begin@\n" in
    let () = List.iter (gen_test fmt path) pbs in
    let () = Format.fprintf fmt "; Auto-generated part end@." in
    close_out ch


(* Generating tests recursively for a folder and its children *)
(* ************************************************************************* *)

let rec gen_tests_rec path =
  let files, folders = scan_folder path in
  let () = gen_tests path files in
  List.iter gen_tests_rec (List.map (Filename.concat path) folders)


(* Main point of entry *)
(* ************************************************************************* *)

let () =
  let root = if Array.length Sys.argv >= 2 then Sys.argv.(1) else "." in
  gen_tests_rec root

