<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>T (dolmen_type.Dolmen_type.Arith.Smtlib2.Real_Int.Tff.Type.T)</title><link rel="stylesheet" href="../../../../../../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../../../../index.html">dolmen_type</a> &#x00BB; <a href="../../../../../../index.html">Dolmen_type</a> &#x00BB; <a href="../../../../../index.html">Arith</a> &#x00BB; <a href="../../../../index.html">Smtlib2</a> &#x00BB; <a href="../../../index.html">Real_Int</a> &#x00BB; <a href="../../index.html">Tff</a> &#x00BB; <a href="../index.html">Type</a> &#x00BB; T</nav><header class="odoc-preamble"><h1>Module <code><span>Type.T</span></code></h1><p>Signature required by terms for typing first-order polymorphic terms.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The type of terms and term variables.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ty"><a href="#val-ty" class="anchor"></a><code><span><span class="keyword">val</span> ty : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Ty/index.html#type-t">Ty.t</a></span></code></div><div class="spec-doc"><p>Returns the type of a term.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print"><a href="#val-print" class="anchor"></a><code><span><span class="keyword">val</span> print : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Printing function for terms.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Var"><a href="#module-Var" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Var/index.html">Var</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A module for variables that occur in terms.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Const"><a href="#module-Const" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Const/index.html">Const</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A module for constant symbols that occur in terms.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Cstr"><a href="#module-Cstr" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Cstr/index.html">Cstr</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A module for Algebraic datatype constructors.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Field"><a href="#module-Field" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Field/index.html">Field</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-define_adt"><a href="#val-define_adt" class="anchor"></a><code><span><span class="keyword">val</span> define_adt : 
  <span><a href="../Ty/Const/index.html#type-t">Ty.Const.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Ty/Var/index.html#type-t">Ty.Var.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../../../../../../../../dolmen/Dolmen_std/Path/index.html#type-t">Dolmen.Std.Path.t</a> * <span><span>(<a href="../Ty/index.html#type-t">Ty.t</a> * <span><a href="../../../../../../../../dolmen/Dolmen_std/Path/index.html#type-t">Dolmen.Std.Path.t</a> option</span>)</span> list</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Ty/index.html#type-def">Ty.def</a> * <span><span>(<a href="Cstr/index.html#type-t">Cstr.t</a> * <span><span>(<a href="../Ty/index.html#type-t">Ty.t</a> * <span><a href="Const/index.html#type-t">Const.t</a> option</span>)</span> list</span>)</span> list</span></span></code></div><div class="spec-doc"><p><code>define_aft t vars cstrs</code> defines the type constant <code>t</code>, parametrised over the type variables <code>ty_vars</code> as defining an algebraic datatypes with constructors <code>cstrs</code>. <code>cstrs</code> is a list where each elements of the form <code>(name, l)</code> defines a new constructor for the algebraic datatype, with the given name. The list <code>l</code> defines the arguments to said constructor, each element of the list giving the type <code>ty</code> of the argument expected by the constructor (which may contain any of the type variables in <code>vars</code>), as well as an optional destructor name. If the construcotr name is <code>Some s</code>, then the ADT definition also defines a function that acts as destructor for that particular field. This polymorphic function is expected to takes as arguments as many types as there are variables in <code>vars</code>, an element of the algebraic datatype being defined, and returns a value for the given field. For instance, consider the following definition for polymorphic lists: <code>define_adt list [ty_var_a] [
        &quot;nil&quot;, [];
        &quot;const&quot;, [
          (Ty.of_var ty_var_a , Some &quot;hd&quot;);
          (ty_list_a          , Some &quot;tl&quot;);
          ];
       ]
      </code> This definition defines the usual type of polymorphic linked lists, as well as two destructors &quot;hd&quot; and &quot;tl&quot;. &quot;hd&quot; would have type <code>forall alpha. alpha list -&gt; a</code>, and be the partial function returning the head of the list.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-define_record"><a href="#val-define_record" class="anchor"></a><code><span><span class="keyword">val</span> define_record : 
  <span><a href="../Ty/Const/index.html#type-t">Ty.Const.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Ty/Var/index.html#type-t">Ty.Var.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../../../../../../../../dolmen/Dolmen_std/Path/index.html#type-t">Dolmen.Std.Path.t</a> * <a href="../Ty/index.html#type-t">Ty.t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Ty/index.html#type-def">Ty.def</a> * <span><a href="Field/index.html#type-t">Field.t</a> list</span></span></code></div><div class="spec-doc"><p>Define a (previously abstract) type to be a record type, with the given fields.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Wrong_type"><a href="#exception-Wrong_type" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Wrong_type</span> <span class="keyword">of</span> <a href="#type-t">t</a> * <a href="../Ty/index.html#type-t">Ty.t</a></span></code></div><div class="spec-doc"><p>Exception raised in case of typing error during term construction. <code>Wrong_type (t, ty)</code> should be raised by term constructor functions when some term <code>t</code> is expected to have type <code>ty</code>, but does not have that type.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Wrong_sum_type"><a href="#exception-Wrong_sum_type" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Wrong_sum_type</span> <span class="keyword">of</span> <a href="Cstr/index.html#type-t">Cstr.t</a> * <a href="../Ty/index.html#type-t">Ty.t</a></span></code></div><div class="spec-doc"><p>Raised when some constructor was expected to belong to some type but does not belong to the given type.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Wrong_record_type"><a href="#exception-Wrong_record_type" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Wrong_record_type</span> <span class="keyword">of</span> <a href="Field/index.html#type-t">Field.t</a> * <a href="../Ty/Const/index.html#type-t">Ty.Const.t</a></span></code></div><div class="spec-doc"><p>Exception raised in case of typing error during term construction. This should be raised when the returned field was expected to be a field for the returned record type constant, but it was of another record type.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Field_repeated"><a href="#exception-Field_repeated" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Field_repeated</span> <span class="keyword">of</span> <a href="Field/index.html#type-t">Field.t</a></span></code></div><div class="spec-doc"><p>Field repeated in a record expression.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Field_missing"><a href="#exception-Field_missing" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Field_missing</span> <span class="keyword">of</span> <a href="Field/index.html#type-t">Field.t</a></span></code></div><div class="spec-doc"><p>Field missing in a record expression.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Pattern_expected"><a href="#exception-Pattern_expected" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Pattern_expected</span> <span class="keyword">of</span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Raised when trying to create a pattern matching, but a non-pattern term was provided where a pattern was expected.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Empty_pattern_matching"><a href="#exception-Empty_pattern_matching" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Empty_pattern_matching</span></span></code></div><div class="spec-doc"><p>Raise when creating a pattern matching but an empty list of branches was provided</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Partial_pattern_match"><a href="#exception-Partial_pattern_match" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Partial_pattern_match</span> <span class="keyword">of</span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p>Raised when a partial pattern matching was created. A list of terms not covered by the patterns is provided.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Over_application"><a href="#exception-Over_application" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Over_application</span> <span class="keyword">of</span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p>Raised when an application was provided too many term arguments. The extraneous arguments are returned by the exception.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Bad_poly_arity"><a href="#exception-Bad_poly_arity" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Bad_poly_arity</span> <span class="keyword">of</span> <span><a href="../Ty/Var/index.html#type-t">Ty.Var.t</a> list</span> * <span><a href="../Ty/index.html#type-t">Ty.t</a> list</span></span></code></div><div class="spec-doc"><p>Raised when a polymorphic application does not have an adequate number of arguments.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ensure"><a href="#val-ensure" class="anchor"></a><code><span><span class="keyword">val</span> ensure : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Ty/index.html#type-t">Ty.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Ensure that a given term has the given type.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_var"><a href="#val-of_var" class="anchor"></a><code><span><span class="keyword">val</span> of_var : <span><a href="Var/index.html#type-t">Var.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a term from a variable</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-apply_cst"><a href="#val-apply_cst" class="anchor"></a><code><span><span class="keyword">val</span> apply_cst : <span><a href="Const/index.html#type-t">Const.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Ty/index.html#type-t">Ty.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Polymorphic application of a constant.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-apply_cstr"><a href="#val-apply_cstr" class="anchor"></a><code><span><span class="keyword">val</span> apply_cstr : <span><a href="Cstr/index.html#type-t">Cstr.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Ty/index.html#type-t">Ty.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Polymorphic application of a constructor.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-apply_field"><a href="#val-apply_field" class="anchor"></a><code><span><span class="keyword">val</span> apply_field : <span><a href="Field/index.html#type-t">Field.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Apply a field to a record.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-record"><a href="#val-record" class="anchor"></a><code><span><span class="keyword">val</span> record : <span><span><span>(<a href="Field/index.html#type-t">Field.t</a> * <a href="#type-t">t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a record.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-record_with"><a href="#val-record_with" class="anchor"></a><code><span><span class="keyword">val</span> record_with : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="Field/index.html#type-t">Field.t</a> * <a href="#type-t">t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create an updated record</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cstr_tester"><a href="#val-cstr_tester" class="anchor"></a><code><span><span class="keyword">val</span> cstr_tester : <span><a href="Cstr/index.html#type-t">Cstr.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Given a constructor <code>c</code> and a term <code>t</code>, returns a terms that evaluates to <code>true</code> iff <code>t</code> has <code>c</code> as head constructor.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-_and"><a href="#val-_and" class="anchor"></a><code><span><span class="keyword">val</span> _and : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Conjunction of formulas</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lam"><a href="#val-lam" class="anchor"></a><code><span><span class="keyword">val</span> lam : <span><span>(<span><a href="../Ty/Var/index.html#type-t">Ty.Var.t</a> list</span> * <span><a href="Var/index.html#type-t">Var.t</a> list</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a local function.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-all"><a href="#val-all" class="anchor"></a><code><span><span class="keyword">val</span> all : <span><span>(<span><a href="../Ty/Var/index.html#type-t">Ty.Var.t</a> list</span> * <span><a href="Var/index.html#type-t">Var.t</a> list</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Universally quantify the given formula over the type and terms variables.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ex"><a href="#val-ex" class="anchor"></a><code><span><span class="keyword">val</span> ex : <span><span>(<span><a href="../Ty/Var/index.html#type-t">Ty.Var.t</a> list</span> * <span><a href="Var/index.html#type-t">Var.t</a> list</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Existencially quantify the given formula over the type and terms variables.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span><span class="keyword">val</span> bind : <span><a href="Var/index.html#type-t">Var.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Bind a variable to an expressions. This function is called when typing a let-binding, before the body of the let-binding is typed. The returned expressions is used to replace the variable everywhere in the body of the let-binding being typed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-letin"><a href="#val-letin" class="anchor"></a><code><span><span class="keyword">val</span> letin : <span><span><span>(<a href="Var/index.html#type-t">Var.t</a> * <a href="#type-t">t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a sequential let-binding.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-letand"><a href="#val-letand" class="anchor"></a><code><span><span class="keyword">val</span> letand : <span><span><span>(<a href="Var/index.html#type-t">Var.t</a> * <a href="#type-t">t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a parrallel let-binding.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pattern_match"><a href="#val-pattern_match" class="anchor"></a><code><span><span class="keyword">val</span> pattern_match : <span>?redundant:<span>(<span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="#type-t">t</a> * <a href="#type-t">t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>pattern_match scrutinee branches</code> creates a pattern match expression on the scrutinee with the given branches, each of the form <code>(pattern, body)</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_tag"><a href="#val-set_tag" class="anchor"></a><code><span><span class="keyword">val</span> set_tag : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Tag/index.html#type-t">Tag.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Annotate the given formula wiht the tag and value.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_tag"><a href="#val-add_tag" class="anchor"></a><code><span><span class="keyword">val</span> add_tag : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span class="type-var">'a</span> list</span> <a href="../Tag/index.html#type-t">Tag.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Add a value to the list of values bound to a tag.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fv"><a href="#val-fv" class="anchor"></a><code><span><span class="keyword">val</span> fv : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Ty/Var/index.html#type-t">Ty.Var.t</a> list</span> * <span><a href="Var/index.html#type-t">Var.t</a> list</span></span></code></div><div class="spec-doc"><p>Returns the list of free variables in the formula.</p></div></div></div></body></html>