<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Logic (dolmen.Dolmen_intf__Stmt.Logic)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">dolmen</a> &#x00BB; <a href="../index.html">Dolmen_intf__Stmt</a> &#x00BB; Logic</nav><h1>Module type <code>Dolmen_intf__Stmt.Logic</code></h1></header><aside><p>Signature used by the Logic class, which parses languages such as tptp, smtlib, etc... Statements of dirrent languages currently have a lot less in common than terms, so this interface looks a lot more like a patchwork of different logical framework directives than it should.</p></aside><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code></dt><dd><p>The type of statements.</p></dd></dl><dl><dt class="spec type" id="type-id"><a href="#type-id" class="anchor"></a><code><span class="keyword">type </span>id</code></dt><dd><p>The type of identifiers.</p></dd></dl><dl><dt class="spec type" id="type-term"><a href="#type-term" class="anchor"></a><code><span class="keyword">type </span>term</code></dt><dd><p>The type of terms used in statements.</p></dd></dl><dl><dt class="spec type" id="type-location"><a href="#type-location" class="anchor"></a><code><span class="keyword">type </span>location</code></dt><dd><p>The type of locations attached to statements.</p></dd></dl><section><header><h2 id="optional-infos-for-statements"><a href="#optional-infos-for-statements" class="anchor"></a>Optional infos for statements</h2></header><dl><dt class="spec value" id="val-annot"><a href="#val-annot" class="anchor"></a><code><span class="keyword">val </span>annot : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dd><p>Constructors for annotations. Annotations are mainly used in TPTP.</p></dd></dl></section><section><header><h2 id="generic-statements"><a href="#generic-statements" class="anchor"></a>Generic statements</h2></header><dl><dt class="spec value" id="val-import"><a href="#val-import" class="anchor"></a><code><span class="keyword">val </span>import : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Import directive. Same as <code>include_</code> but without filtering on the statements to import.</p></dd></dl><dl><dt class="spec value" id="val-include_"><a href="#val-include_" class="anchor"></a><code><span class="keyword">val </span>include_ : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Inlcude directive. <code>include file l</code> means to include in the current scope the directives from file <code>file</code> that appear in <code>l</code>. If <code>l</code> is the empty list, all directives should be imported.</p></dd></dl></section><section><header><h2 id="dimacs&amp;icnf-statements"><a href="#dimacs&amp;icnf-statements" class="anchor"></a>Dimacs&amp;iCNF Statements</h2></header><dl><dt class="spec value" id="val-p_cnf"><a href="#val-p_cnf" class="anchor"></a><code><span class="keyword">val </span>p_cnf : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Header of dimacs files. First argument is the number of variables, second is the number of clauses.</p></dd></dl><dl><dt class="spec value" id="val-clause"><a href="#val-clause" class="anchor"></a><code><span class="keyword">val </span>clause : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Add to the current set of assertions the given list of terms as a clause.</p></dd></dl><dl><dt class="spec value" id="val-assumption"><a href="#val-assumption" class="anchor"></a><code><span class="keyword">val </span>assumption : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Solve the current set of assertions, with the given assumptions.</p></dd></dl></section><section><header><h2 id="smtlib-statements"><a href="#smtlib-statements" class="anchor"></a>Smtlib statements</h2></header><dl><dt class="spec value" id="val-pop"><a href="#val-pop" class="anchor"></a><code><span class="keyword">val </span>pop : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-push"><a href="#val-push" class="anchor"></a><code><span class="keyword">val </span>push : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Directives for manipulating the set of assertions. Push directives creates backtrack point that can be reached using Pop directives.</p></dd></dl><dl><dt class="spec value" id="val-reset_assertions"><a href="#val-reset_assertions" class="anchor"></a><code><span class="keyword">val </span>reset_assertions : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Reset all assertions that hase been pushed.</p></dd></dl><dl><dt class="spec value" id="val-assert_"><a href="#val-assert_" class="anchor"></a><code><span class="keyword">val </span>assert_ : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Add an assertion to the current set of assertions.</p></dd></dl><dl><dt class="spec value" id="val-check_sat"><a href="#val-check_sat" class="anchor"></a><code><span class="keyword">val </span>check_sat : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Directive that instructs the prover to solve the current set of assertions, undr some local assumptions.</p></dd></dl><dl><dt class="spec value" id="val-set_logic"><a href="#val-set_logic" class="anchor"></a><code><span class="keyword">val </span>set_logic : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Set the logic to be used for solving.</p></dd></dl><dl><dt class="spec value" id="val-get_info"><a href="#val-get_info" class="anchor"></a><code><span class="keyword">val </span>get_info : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-set_info"><a href="#val-set_info" class="anchor"></a><code><span class="keyword">val </span>set_info : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Getter and setter for various informations (see smtlib manual).</p></dd></dl><dl><dt class="spec value" id="val-get_option"><a href="#val-get_option" class="anchor"></a><code><span class="keyword">val </span>get_option : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-set_option"><a href="#val-set_option" class="anchor"></a><code><span class="keyword">val </span>set_option : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Getter and setter for prover options (see smtlib manual).</p></dd></dl><dl><dt class="spec value" id="val-type_decl"><a href="#val-type_decl" class="anchor"></a><code><span class="keyword">val </span>type_decl : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Type declaration. <code>type_decl s n</code> declare <code>s</code> as a type constructor with arity <code>n</code>.</p></dd></dl><dl><dt class="spec value" id="val-type_def"><a href="#val-type_def" class="anchor"></a><code><span class="keyword">val </span>type_def : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> list <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Type definition. <code>type_def f args body</code> declare that <code>f(args) = body</code>, i.e any occurence of &quot;f(l)&quot; should be replaced by <code>body</code> where the &quot;args&quot; have been substituted by their corresponding value in <code>l</code>.</p></dd></dl><dl><dt class="spec value" id="val-datatypes"><a href="#val-datatypes" class="anchor"></a><code><span class="keyword">val </span>datatypes : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> (<a href="index.html#type-id">id</a><span class="keyword"> * </span><a href="index.html#type-term">term</a> list<span class="keyword"> * </span>(<a href="index.html#type-id">id</a><span class="keyword"> * </span><a href="index.html#type-term">term</a> list) list) list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Inductive type definitions. TODO: some more documentation.</p></dd></dl><dl><dt class="spec value" id="val-fun_decl"><a href="#val-fun_decl" class="anchor"></a><code><span class="keyword">val </span>fun_decl : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Symbol declaration. <code>fun_decl f args ret</code> defines <code>f</code> as a function which takes arguments of type as described in <code>args</code> and which returns a value of type <code>ret</code>.</p></dd></dl><dl><dt class="spec value" id="val-fun_def"><a href="#val-fun_def" class="anchor"></a><code><span class="keyword">val </span>fun_def : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Symbol definition. <code>fun_def f args ret body</code> means that &quot;f(args) = (body : ret)&quot;, i.e f is a function symbol with arguments <code>args</code>, and which returns the value <code>body</code> which is of type <code>ret</code>.</p></dd></dl><dl><dt class="spec value" id="val-funs_def_rec"><a href="#val-funs_def_rec" class="anchor"></a><code><span class="keyword">val </span>funs_def_rec : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> (<a href="index.html#type-id">id</a><span class="keyword"> * </span><a href="index.html#type-term">term</a> list<span class="keyword"> * </span><a href="index.html#type-term">term</a><span class="keyword"> * </span><a href="index.html#type-term">term</a>) list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Define a list of mutually recursive functions. Each functions has the same definition as in <code>fun_def</code></p></dd></dl><dl><dt class="spec value" id="val-get_proof"><a href="#val-get_proof" class="anchor"></a><code><span class="keyword">val </span>get_proof : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>If the last call to <code>check_sat</code> returned UNSAT, then instruct the prover to return the proof of unsat.</p></dd></dl><dl><dt class="spec value" id="val-get_unsat_core"><a href="#val-get_unsat_core" class="anchor"></a><code><span class="keyword">val </span>get_unsat_core : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>If the last call to <code>check_sat</code> returned UNSAT, then instruct the prover to return the unsat core of the unsatisfiability proof, i.e the smallest set of assertions needed to prove <code>false</code>.</p></dd></dl><dl><dt class="spec value" id="val-get_unsat_assumptions"><a href="#val-get_unsat_assumptions" class="anchor"></a><code><span class="keyword">val </span>get_unsat_assumptions : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>If the last call to <code>check_sat</code> returned UNSAT, then instruct the prover to return a subset of the local assumptions that is sufficient to deduce UNSAT.</p></dd></dl><dl><dt class="spec value" id="val-get_model"><a href="#val-get_model" class="anchor"></a><code><span class="keyword">val </span>get_model : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>If the last call to <code>check_sat</code> returned SAT, then return the associated model.</p></dd></dl><dl><dt class="spec value" id="val-get_value"><a href="#val-get_value" class="anchor"></a><code><span class="keyword">val </span>get_value : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Instructs the prover to return the values of the given closed quantifier-free terms.</p></dd></dl><dl><dt class="spec value" id="val-get_assignment"><a href="#val-get_assignment" class="anchor"></a><code><span class="keyword">val </span>get_assignment : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Instructs the prover to return truth assignemnt for labelled formulas (see smtlib manual for more information).</p></dd></dl><dl><dt class="spec value" id="val-get_assertions"><a href="#val-get_assertions" class="anchor"></a><code><span class="keyword">val </span>get_assertions : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Instructs the prover to print all current assertions.</p></dd></dl><dl><dt class="spec value" id="val-echo"><a href="#val-echo" class="anchor"></a><code><span class="keyword">val </span>echo : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Print the given sting.</p></dd></dl><dl><dt class="spec value" id="val-reset"><a href="#val-reset" class="anchor"></a><code><span class="keyword">val </span>reset : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Full reset of the prover state.</p></dd></dl><dl><dt class="spec value" id="val-exit"><a href="#val-exit" class="anchor"></a><code><span class="keyword">val </span>exit : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Exit directive (used in interactive mode).</p></dd></dl></section><section><header><h2 id="tptp-statements"><a href="#tptp-statements" class="anchor"></a>TPTP Statements</h2></header><dl><dt class="spec value" id="val-tpi"><a href="#val-tpi" class="anchor"></a><code><span class="keyword">val </span>tpi : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;annot:<a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-thf"><a href="#val-thf" class="anchor"></a><code><span class="keyword">val </span>thf : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;annot:<a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-tff"><a href="#val-tff" class="anchor"></a><code><span class="keyword">val </span>tff : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;annot:<a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-fof"><a href="#val-fof" class="anchor"></a><code><span class="keyword">val </span>fof : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;annot:<a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-cnf"><a href="#val-cnf" class="anchor"></a><code><span class="keyword">val </span>cnf : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;annot:<a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>TPTP directives. <code>tptp name role t</code> instructs the prover to register a new directive with the given name, role and term. Current tptp roles are:</p><ul><li><code>&quot;axiom&quot;, &quot;hypothesis&quot;, &quot;definition&quot;, &quot;lemma&quot;, &quot;theorem&quot;</code> acts as new assertions/declartions</li><li><p><code>&quot;assumption&quot;, &quot;conjecture&quot;</code> are proposition that need to be proved, and then can be used to prove other propositions. They are equivalent to the following sequence of smtlib statements:</p><ul><li><code>push 1</code></li><li><code>assert (not t)</code></li><li><code>check_sat</code></li><li><code>pop 1</code></li><li><code>assert t</code></li></ul></li><li><code>&quot;negated_conjecture&quot;</code> is the same as <code>&quot;conjecture&quot;</code>, but the given proposition is false (i.e its negation is the proposition to prove).</li><li><code>&quot;type&quot;</code> declares a new symbol and its type</li><li><code>&quot;plain&quot;, &quot;unknown&quot;, &quot;fi_domain&quot;, &quot;fi_functors&quot;, &quot;fi_predicates&quot;</code> are valid roles with no specified semantics</li><li>any other role is an error</li></ul></dd></dl></section><section><header><h2 id="zipperposition-statements"><a href="#zipperposition-statements" class="anchor"></a>Zipperposition statements</h2></header><dl><dt class="spec value" id="val-data"><a href="#val-data" class="anchor"></a><code><span class="keyword">val </span>data : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;attrs:<a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Packs a list of mutually recursive inductive type declarations into a single statement.</p></dd></dl><dl><dt class="spec value" id="val-defs"><a href="#val-defs" class="anchor"></a><code><span class="keyword">val </span>defs : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;attrs:<a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Packs a list of mutually recursive definitions into a single statement.</p></dd></dl><dl><dt class="spec value" id="val-rewrite"><a href="#val-rewrite" class="anchor"></a><code><span class="keyword">val </span>rewrite : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;attrs:<a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Declare a rewrite rule, i.e a universally quantified equality or equivalence that can be oriented according to a specific ordering.</p></dd></dl><dl><dt class="spec value" id="val-goal"><a href="#val-goal" class="anchor"></a><code><span class="keyword">val </span>goal : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;attrs:<a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The goal, i.e the propositional formula to prove.</p></dd></dl><dl><dt class="spec value" id="val-assume"><a href="#val-assume" class="anchor"></a><code><span class="keyword">val </span>assume : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;attrs:<a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Adds an hypothesis.</p></dd></dl><dl><dt class="spec value" id="val-lemma"><a href="#val-lemma" class="anchor"></a><code><span class="keyword">val </span>lemma : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;attrs:<a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Lemmas.</p></dd></dl><dl><dt class="spec value" id="val-decl"><a href="#val-decl" class="anchor"></a><code><span class="keyword">val </span>decl : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;attrs:<a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Symbol declaration. <code>decl name ty</code> declares a new symbol <code>name</code> with type <code>ty</code>.</p></dd></dl><dl><dt class="spec value" id="val-definition"><a href="#val-definition" class="anchor"></a><code><span class="keyword">val </span>definition : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;attrs:<a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Symbol definition. <code>def name ty term</code> defines a new symbol <code>name</code> of type <code>ty</code> which is equal to <code>term</code>.</p></dd></dl><dl><dt class="spec value" id="val-inductive"><a href="#val-inductive" class="anchor"></a><code><span class="keyword">val </span>inductive : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;attrs:<a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> (<a href="index.html#type-id">id</a><span class="keyword"> * </span><a href="index.html#type-term">term</a> list) list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Inductive type definitions. <code>inductive name vars l</code> defines an inductive type <code>name</code>, with polymorphic variables <code>vars</code>, and with a list of inductive constructors <code>l</code>.</p></dd></dl></section></div></body></html>