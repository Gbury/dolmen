<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Prop (dolmen.Dolmen_std.Builtin.Prop)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">Index</a> &#x00BB; <a href="../../../index.html">dolmen</a> &#x00BB; <a href="../../index.html">Dolmen_std</a> &#x00BB; <a href="../index.html">Builtin</a> &#x00BB; Prop</nav><header class="odoc-preamble"><h1>Module <code><span>Builtin.Prop</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>_ t</span></span><span> = </span></code><ol><li id="type-t.T" class="def variant constructor anchored"><a href="#type-t.T" class="anchor"></a><code><span>| </span><span><span class="constructor">T</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Prop.T.T: ttype</code>: the builtin type constant for the type of propositions / booleans.</p><span class="comment-delim">*)</span></div></li><li id="type-t.True" class="def variant constructor anchored"><a href="#type-t.True" class="anchor"></a><code><span>| </span><span><span class="constructor">True</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>True: Prop.T</code>: the <code>true</code> proposition.</p><span class="comment-delim">*)</span></div></li><li id="type-t.False" class="def variant constructor anchored"><a href="#type-t.False" class="anchor"></a><code><span>| </span><span><span class="constructor">False</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>False: Prop.T</code>: the <code>false</code> proposition.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Neg" class="def variant constructor anchored"><a href="#type-t.Neg" class="anchor"></a><code><span>| </span><span><span class="constructor">Neg</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Neg: Prop.T -&gt; Prop.T</code>: propositional negation.</p><span class="comment-delim">*)</span></div></li><li id="type-t.And" class="def variant constructor anchored"><a href="#type-t.And" class="anchor"></a><code><span>| </span><span><span class="constructor">And</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>And: Prop.T -&gt; ... -&gt; Prop.T</code>: propositional conjunction.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Or" class="def variant constructor anchored"><a href="#type-t.Or" class="anchor"></a><code><span>| </span><span><span class="constructor">Or</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Or: Prop.T -&gt; ... -&gt; Prop.T</code>: propositional disjunction.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Nand" class="def variant constructor anchored"><a href="#type-t.Nand" class="anchor"></a><code><span>| </span><span><span class="constructor">Nand</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Nand: Prop.T -&gt; Prop.T -&gt; Prop.T</code>: propositional negated conjunction.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Nor" class="def variant constructor anchored"><a href="#type-t.Nor" class="anchor"></a><code><span>| </span><span><span class="constructor">Nor</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Nor: Prop.T -&gt; Prop.T -&gt; Prop.T</code>: propositional negated disjunction.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Xor" class="def variant constructor anchored"><a href="#type-t.Xor" class="anchor"></a><code><span>| </span><span><span class="constructor">Xor</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Xor: Prop.T -&gt; Prop.T -&gt; Prop.T</code>: ppropositional exclusive disjunction.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Imply" class="def variant constructor anchored"><a href="#type-t.Imply" class="anchor"></a><code><span>| </span><span><span class="constructor">Imply</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Imply: Prop.T -&gt; Prop.T -&gt; Prop.T</code>: propositional implication.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Implied" class="def variant constructor anchored"><a href="#type-t.Implied" class="anchor"></a><code><span>| </span><span><span class="constructor">Implied</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Implied: Prop.T -&gt; Prop.T -&gt; Prop.T</code>: reverse propositional implication.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Equiv" class="def variant constructor anchored"><a href="#type-t.Equiv" class="anchor"></a><code><span>| </span><span><span class="constructor">Equiv</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Equiv: Prop.T -&gt; Prop.T -&gt; Prop.T</code>: propositional Equivalence.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Ite" class="def variant constructor anchored"><a href="#type-t.Ite" class="anchor"></a><code><span>| </span><span><span class="constructor">Ite</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Ite: 'a. Prop.T -&gt; 'a -&gt; 'a -&gt; 'a</code>: branching operator.</p><span class="comment-delim">*)</span></div></li></ol></div></div></div></body></html>
