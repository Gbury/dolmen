<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Builtin (dolmen.Dolmen_std.Builtin)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">dolmen</a> &#x00BB; <a href="../index.html">Dolmen_std</a> &#x00BB; Builtin</nav><header class="odoc-preamble"><h1>Module <code><span>Dolmen_std.Builtin</span></code></h1><p>This module defines the builtins that are defined by Dolmen.</p><p>Builtins are particularly used in typed expressions see <a href="../Expr/index.html"><code>Dolmen.Std.Expr</code></a>, in order to give more information about constants which have builtin semantics.</p><p>Users are encouraged to match builtins rather than specific symbols when inspecting typed expressions, as this basically allows to match on the semantics of an identifier rather than matching on the syntaxic value of an identifier. For instance, equality can take an arbitrary number of arguments, and thus in order to have well-typed terms, each arity of equality gives rise to a different symbol (because the symbol's type depends on the arity desired), but all these symbols have the <code>Equal</code> builtin.</p><p>In the following we will use pseudo-code to describe the arity and actual type associated to builtins. These will follow ocaml's notation for types with an additional syntax using dots for arbitrary arity. Some examples:</p><ul><li><code>ttype</code> is a type constant</li><li><code>ttype -&gt; ttype</code> is a type constructor (e.g. <code>list</code>)</li><li><code>int</code> is a constant of type <code>int</code></li><li><code>float -&gt; int</code> is a unary function</li><li><code>'a. 'a -&gt; 'a</code> is a polymorphic unary function</li><li><code>'a. 'a -&gt; ... -&gt; Prop</code> describes a family of functions that take a type and then an arbitrary number of arguments of that type, and return a proposition (this is for instance the type of equality).</li></ul><p>Additionally, due to some languages having overloaded operators, and in order to not have too verbose names, some of these builtins may have overloaded signtures, such as comparisons on numbers which can operate on integers, rationals, or reals. Note that arbitrary arity operators (well family of operators) can be also be seen as overloaded operators. Overloaded types (particularly for numbers) are written:</p><ul><li><code>{a=(Int|Rational|Real)} a -&gt; a -&gt; Prop</code>, where the notable difference with polymorphic functions is that functions of this type does not take a type argument.</li></ul></header><nav class="odoc-toc"><ul><li><a href="#type-definition">Type definition</a></li><li><a href="#base-builtins">Base Builtins</a></li><li><a href="#boolean-builtins">Boolean Builtins</a></li><li><a href="#algebraic-datatype-builtins">Algebraic datatype Builtins</a></li><li><a href="#arithmetic-builtins">Arithmetic Builtins</a></li><li><a href="#arrays-builtins">Arrays Builtins</a></li><li><a href="#bitvectors-builtins">Bitvectors Builtins</a></li><li><a href="#floats-builtins">Floats Builtins</a></li><li><a href="#string-and-regexp-builtins">String and Regexp Builtins</a></li></ul></nav><div class="odoc-content"><h3 id="type-definition"><a href="#type-definition" class="anchor"></a>Type definition</h3><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span><span> = </span><span>..</span><span> <span class="keyword">constraint</span> <span class="type-var">'a</span> = <span>&lt; .. &gt;</span></span></code></div></div><h3 id="base-builtins"><a href="#base-builtins" class="anchor"></a>Base Builtins</h3><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Base"><a href="#extension-decl-Base" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Base" class="def extension anchored"><a href="#extension-Base" class="anchor"></a><code><span>| </span><span><span class="extension">Base</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The base builtin; it is the default builtin for identifiers.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Wildcard"><a href="#extension-decl-Wildcard" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Wildcard" class="def extension anchored"><a href="#extension-Wildcard" class="anchor"></a><code><span>| </span><span><span class="extension">Wildcard</span> : </span><span>{</span></code><ol><li id="module-Builtin.ty" class="def record field anchored"><a href="#module-Builtin.ty" class="anchor"></a><code><span>ty : <span><span><span class="type-var">'ty</span> option</span> <span class="xref-unresolved">Stdlib</span>.ref</span>;</span></code></li></ol><code><span>}</span><span> <span class="arrow">&#45;&gt;</span> <span><span>&lt; ty : <span class="type-var">'ty</span>.. &gt;</span> <a href="#type-t">t</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Wildcards, currently used internally to represent implicit type variables during type-checking.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Kind"><a href="#extension-decl-Kind" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Kind" class="def extension anchored"><a href="#extension-Kind" class="anchor"></a><code><span>| </span><span><span class="extension">Kind</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Used for the type of <code>Type</code>. It is an error to try and access the type of kind.</p><span class="comment-delim">*)</span></div></li><li id="extension-Type" class="def extension anchored"><a href="#extension-Type" class="anchor"></a><code><span>| </span><span><span class="extension">Type</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Builtin used to represent the type of types.</p><span class="comment-delim">*)</span></div></li><li id="extension-Prop" class="def extension anchored"><a href="#extension-Prop" class="anchor"></a><code><span>| </span><span><span class="extension">Prop</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Prop: ttype</code>: the builtin type constant for the type of propositions / booleans.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Unit"><a href="#extension-decl-Unit" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Unit" class="def extension anchored"><a href="#extension-Unit" class="anchor"></a><code><span>| </span><span><span class="extension">Unit</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The unit type, which has only one element (named void).</p><span class="comment-delim">*)</span></div></li><li id="extension-Univ" class="def extension anchored"><a href="#extension-Univ" class="anchor"></a><code><span>| </span><span><span class="extension">Univ</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Univ: ttype</code>: a builtin type constant used for languages with a default type for elements (such as tptp's `$i`).</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Coercion"><a href="#extension-decl-Coercion" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Coercion" class="def extension anchored"><a href="#extension-Coercion" class="anchor"></a><code><span>| </span><span><span class="extension">Coercion</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Coercion: 'a 'b. 'a -&gt; 'b</code>: Coercion/cast operator, i.e. allows to cast values of some type to another type. This is a polymorphic operator that takes two type arguments <code>a</code> and <code>b</code>, a value of type <code>a</code>, and returns a value of type <code>b</code>. The interpretation/semantics of this cast can remain up to the user. This operator is currently mainly used to cast numeric types when this transormation is exact (i.e. an integer casted into a rational, which is always possible and exact, or the cast of a rational into an integer, as long as the cast is guarded by a clause verifying the rational is an integer).</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-In_interval"><a href="#extension-decl-In_interval" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-In_interval" class="def extension anchored"><a href="#extension-In_interval" class="anchor"></a><code><span>| </span><span><span class="extension">In_interval</span> <span class="keyword">of</span> bool * bool</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>In_interval (b1, b2): Int -&gt; Int -&gt; Int -&gt; Prop</code>: Tests whether or not an interger is in an interval, <code>b1</code> (resp. <code>b2</code>) determines if the interval is open on the lower bound (resp. upper bound).</p><p><code>warning:</code> It is an Alt-Ergo semantic trigger that should only be allowed inside theories.</p><span class="comment-delim">*)</span></div></li><li id="extension-Maps_to" class="def extension anchored"><a href="#extension-Maps_to" class="anchor"></a><code><span>| </span><span><span class="extension">Maps_to</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Maps_to: 'term_var -&gt; 'term -&gt; 'term</code>: Used in semantic triggers for floating point arithmetic. See <code>alt-ergo/src/preludes/fpa-theory-2017-01-04-16h00.ae</code>.</p><p><code>warning:</code> It is an Alt-Ergo semantic trigger that should only be allowed inside theories.</p><span class="comment-delim">*)</span></div></li></ol></div></div><h3 id="boolean-builtins"><a href="#boolean-builtins" class="anchor"></a>Boolean Builtins</h3><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-True"><a href="#extension-decl-True" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-True" class="def extension anchored"><a href="#extension-True" class="anchor"></a><code><span>| </span><span><span class="extension">True</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>True: Prop</code>: the <code>true</code> proposition.</p><span class="comment-delim">*)</span></div></li><li id="extension-False" class="def extension anchored"><a href="#extension-False" class="anchor"></a><code><span>| </span><span><span class="extension">False</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>False: Prop</code>: the <code>false</code> proposition.</p><span class="comment-delim">*)</span></div></li><li id="extension-Equal" class="def extension anchored"><a href="#extension-Equal" class="anchor"></a><code><span>| </span><span><span class="extension">Equal</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Equal: 'a. 'a -&gt; ... -&gt; Prop</code>: equality beetween values.</p><span class="comment-delim">*)</span></div></li><li id="extension-Distinct" class="def extension anchored"><a href="#extension-Distinct" class="anchor"></a><code><span>| </span><span><span class="extension">Distinct</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Distinct: 'a. 'a -&gt; ... -&gt; Prop</code>: pairwise dis-equality beetween arguments.</p><span class="comment-delim">*)</span></div></li><li id="extension-Neg" class="def extension anchored"><a href="#extension-Neg" class="anchor"></a><code><span>| </span><span><span class="extension">Neg</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Neg: Prop -&gt; Prop</code>: propositional negation.</p><span class="comment-delim">*)</span></div></li><li id="extension-And" class="def extension anchored"><a href="#extension-And" class="anchor"></a><code><span>| </span><span><span class="extension">And</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>And: Prop -&gt; ... -&gt; Prop</code>: propositional conjunction.</p><span class="comment-delim">*)</span></div></li><li id="extension-Or" class="def extension anchored"><a href="#extension-Or" class="anchor"></a><code><span>| </span><span><span class="extension">Or</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Or: Prop -&gt; ... -&gt; Prop</code>: propositional disjunction.</p><span class="comment-delim">*)</span></div></li><li id="extension-Nand" class="def extension anchored"><a href="#extension-Nand" class="anchor"></a><code><span>| </span><span><span class="extension">Nand</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Nand: Prop -&gt; Prop -&gt; Prop</code>: propositional negated conjunction.</p><span class="comment-delim">*)</span></div></li><li id="extension-Nor" class="def extension anchored"><a href="#extension-Nor" class="anchor"></a><code><span>| </span><span><span class="extension">Nor</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Nor: Prop -&gt; Prop -&gt; Prop</code>: propositional negated disjunction.</p><span class="comment-delim">*)</span></div></li><li id="extension-Xor" class="def extension anchored"><a href="#extension-Xor" class="anchor"></a><code><span>| </span><span><span class="extension">Xor</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Xor: Prop -&gt; Prop -&gt; Prop</code>: ppropositional exclusive disjunction.</p><span class="comment-delim">*)</span></div></li><li id="extension-Imply" class="def extension anchored"><a href="#extension-Imply" class="anchor"></a><code><span>| </span><span><span class="extension">Imply</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Imply: Prop -&gt; Prop -&gt; Prop</code>: propositional implication.</p><span class="comment-delim">*)</span></div></li><li id="extension-Implied" class="def extension anchored"><a href="#extension-Implied" class="anchor"></a><code><span>| </span><span><span class="extension">Implied</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Implied: Prop -&gt; Prop -&gt; Prop</code>: reverse propositional implication.</p><span class="comment-delim">*)</span></div></li><li id="extension-Equiv" class="def extension anchored"><a href="#extension-Equiv" class="anchor"></a><code><span>| </span><span><span class="extension">Equiv</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Equiv: Prop -&gt; Prop -&gt; Prop</code>: propositional Equivalence.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Ite"><a href="#extension-decl-Ite" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Ite" class="def extension anchored"><a href="#extension-Ite" class="anchor"></a><code><span>| </span><span><span class="extension">Ite</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Ite: 'a. Prop -&gt; 'a -&gt; 'a -&gt; 'a</code>: branching operator.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Pi"><a href="#extension-decl-Pi" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Pi" class="def extension anchored"><a href="#extension-Pi" class="anchor"></a><code><span>| </span><span><span class="extension">Pi</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Pi: 'a. ('a -&gt; Prop) -&gt; Prop</code>: higher-order encoding of universal quantification.</p><span class="comment-delim">*)</span></div></li><li id="extension-Sigma" class="def extension anchored"><a href="#extension-Sigma" class="anchor"></a><code><span>| </span><span><span class="extension">Sigma</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Sigma: 'a. ('a -&gt; Prop) -&gt; Prop</code>: higher-order encoding of existencial quantification.</p><span class="comment-delim">*)</span></div></li></ol></div></div><h3 id="algebraic-datatype-builtins"><a href="#algebraic-datatype-builtins" class="anchor"></a>Algebraic datatype Builtins</h3><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Tester"><a href="#extension-decl-Tester" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Tester" class="def extension anchored"><a href="#extension-Tester" class="anchor"></a><code><span>| </span><span><span class="extension">Tester</span> : </span><span>{</span></code><ol><li id="module-Builtin.adt" class="def record field anchored"><a href="#module-Builtin.adt" class="anchor"></a><code><span>adt : <span class="type-var">'ty_cst</span>;</span></code></li><li id="module-Builtin.case" class="def record field anchored"><a href="#module-Builtin.case" class="anchor"></a><code><span>case : int;</span></code></li><li id="module-Builtin.cstr" class="def record field anchored"><a href="#module-Builtin.cstr" class="anchor"></a><code><span>cstr : <span class="type-var">'term_cst</span>;</span></code></li></ol><code><span>}</span><span> <span class="arrow">&#45;&gt;</span> <span><span>&lt; ty_cst : <span class="type-var">'ty_cst</span> ; term_cst : <span class="type-var">'term_cst</span>.. &gt;</span> <a href="#type-t">t</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Tester { adt; cstr; case; }</code> is the tester of the case-th constructor of type <code>adt</code> which should be <code>cstr</code>.</p><span class="comment-delim">*)</span></div></li><li id="extension-Constructor" class="def extension anchored"><a href="#extension-Constructor" class="anchor"></a><code><span>| </span><span><span class="extension">Constructor</span> : </span><span>{</span></code><ol><li id="module-Builtin.adt" class="def record field anchored"><a href="#module-Builtin.adt" class="anchor"></a><code><span>adt : <span class="type-var">'ty_cst</span>;</span></code></li><li id="module-Builtin.case" class="def record field anchored"><a href="#module-Builtin.case" class="anchor"></a><code><span>case : int;</span></code></li></ol><code><span>}</span><span> <span class="arrow">&#45;&gt;</span> <span><span>&lt; ty_cst : <span class="type-var">'ty_cst</span>.. &gt;</span> <a href="#type-t">t</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Constructor { adt; case}</code> is the case-th constructor of the algebraic datatype defined by <code>adt</code>.</p><span class="comment-delim">*)</span></div></li><li id="extension-Destructor" class="def extension anchored"><a href="#extension-Destructor" class="anchor"></a><code><span>| </span><span><span class="extension">Destructor</span> : </span><span>{</span></code><ol><li id="module-Builtin.adt" class="def record field anchored"><a href="#module-Builtin.adt" class="anchor"></a><code><span>adt : <span class="type-var">'ty_cst</span>;</span></code></li><li id="module-Builtin.case" class="def record field anchored"><a href="#module-Builtin.case" class="anchor"></a><code><span>case : int;</span></code></li><li id="module-Builtin.cstr" class="def record field anchored"><a href="#module-Builtin.cstr" class="anchor"></a><code><span>cstr : <span class="type-var">'term_cst</span>;</span></code></li><li id="module-Builtin.field" class="def record field anchored"><a href="#module-Builtin.field" class="anchor"></a><code><span>field : int;</span></code></li></ol><code><span>}</span><span> <span class="arrow">&#45;&gt;</span> <span><span>&lt; ty_cst : <span class="type-var">'ty_cst</span> ; term_cst : <span class="type-var">'term_cst</span>.. &gt;</span> <a href="#type-t">t</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Destructor { adt; cstr; case; field; }</code> is the destructor returning the field-th argument of the case-th constructor of type <code>adt</code> which should be <code>cstr</code>.</p><span class="comment-delim">*)</span></div></li></ol></div></div><h3 id="arithmetic-builtins"><a href="#arithmetic-builtins" class="anchor"></a>Arithmetic Builtins</h3><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Int"><a href="#extension-decl-Int" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Int" class="def extension anchored"><a href="#extension-Int" class="anchor"></a><code><span>| </span><span><span class="extension">Int</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Int: ttype</code> the type for signed integers of arbitrary precision.</p><span class="comment-delim">*)</span></div></li><li id="extension-Integer" class="def extension anchored"><a href="#extension-Integer" class="anchor"></a><code><span>| </span><span><span class="extension">Integer</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Integer s: Int</code>: integer literal. The string <code>s</code> should be the decimal representation of an integer with arbitrary precision (hence the use of strings rather than the limited precision <code>int</code>).</p><span class="comment-delim">*)</span></div></li><li id="extension-Rat" class="def extension anchored"><a href="#extension-Rat" class="anchor"></a><code><span>| </span><span><span class="extension">Rat</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Rat: ttype</code> the type for signed rationals.</p><span class="comment-delim">*)</span></div></li><li id="extension-Rational" class="def extension anchored"><a href="#extension-Rational" class="anchor"></a><code><span>| </span><span><span class="extension">Rational</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Rational s: Rational</code>: rational literal. The string <code>s</code> should be the decimal representation of a rational (see the various languages spec for more information).</p><span class="comment-delim">*)</span></div></li><li id="extension-Real" class="def extension anchored"><a href="#extension-Real" class="anchor"></a><code><span>| </span><span><span class="extension">Real</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Real: ttype</code> the type for signed reals.</p><span class="comment-delim">*)</span></div></li><li id="extension-Decimal" class="def extension anchored"><a href="#extension-Decimal" class="anchor"></a><code><span>| </span><span><span class="extension">Decimal</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Decimal s: Real</code>: real literals. The string <code>s</code> should be a floating point representation of a real. Not however that reals here means the mathematical abstract notion of real numbers, including irrational, non-algebric numbers, and is thus not restricted to floating point numbers, although these are the only literals supported.</p><p>Note that, in spite of the name, the literals may not be expressed in decimal notation. For instance, <code>Decimal &quot;0x1.0p1&quot;</code> is a valid representation for the real number <code>2</code>.</p><p>Real literals can be parsed using ZArith's <code>Q.of_string</code>.</p><span class="comment-delim">*)</span></div></li><li id="extension-Lt" class="def extension anchored"><a href="#extension-Lt" class="anchor"></a><code><span>| </span><span><span class="extension">Lt</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Lt: {a=(Int|Rational|Real)} a -&gt; a -&gt; Prop</code>: strict comparison (less than) on numbers (whether integers, rationals, or reals).</p><span class="comment-delim">*)</span></div></li><li id="extension-Leq" class="def extension anchored"><a href="#extension-Leq" class="anchor"></a><code><span>| </span><span><span class="extension">Leq</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Leq:{a=(Int|Rational|Real)} a -&gt; a -&gt; Prop</code>: large comparison (less or equal than) on numbers (whether integers, rationals, or reals).</p><span class="comment-delim">*)</span></div></li><li id="extension-Gt" class="def extension anchored"><a href="#extension-Gt" class="anchor"></a><code><span>| </span><span><span class="extension">Gt</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Gt:{a=(Int|Rational|Real)} a -&gt; a -&gt; Prop</code>: strict comparison (greater than) on numbers (whether integers, rationals, or reals).</p><span class="comment-delim">*)</span></div></li><li id="extension-Geq" class="def extension anchored"><a href="#extension-Geq" class="anchor"></a><code><span>| </span><span><span class="extension">Geq</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Geq:{a=(Int|Rational|Real)} a -&gt; a -&gt; Prop</code>: large comparison (greater or equal than) on numbers (whether integers, rationals, or reals).</p><span class="comment-delim">*)</span></div></li><li id="extension-Minus" class="def extension anchored"><a href="#extension-Minus" class="anchor"></a><code><span>| </span><span><span class="extension">Minus</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Minus:{a=(Int|Rational|Real)} a -&gt; a</code>: arithmetic unary negation/minus on numbers (whether integers, rationals, or reals).</p><span class="comment-delim">*)</span></div></li><li id="extension-Add" class="def extension anchored"><a href="#extension-Add" class="anchor"></a><code><span>| </span><span><span class="extension">Add</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Add:{a=(Int|Rational|Real)} a -&gt; a -&gt; a</code>: arithmetic addition on numbers (whether integers, rationals, or reals).</p><span class="comment-delim">*)</span></div></li><li id="extension-Sub" class="def extension anchored"><a href="#extension-Sub" class="anchor"></a><code><span>| </span><span><span class="extension">Sub</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Sub:{a=(Int|Rational|Real)} a -&gt; a -&gt; a</code>: arithmetic substraction on numbers (whether integers, rationals, or reals).</p><span class="comment-delim">*)</span></div></li><li id="extension-Mul" class="def extension anchored"><a href="#extension-Mul" class="anchor"></a><code><span>| </span><span><span class="extension">Mul</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Mul:{a=(Int|Rational|Real)} a -&gt; a -&gt; a</code>: arithmetic multiplication on numbers (whether integers, rationals, or reals).</p><span class="comment-delim">*)</span></div></li><li id="extension-Pow" class="def extension anchored"><a href="#extension-Pow" class="anchor"></a><code><span>| </span><span><span class="extension">Pow</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Pow:{a=(Int|Rational|Real)} a -&gt; a -&gt; a</code>: arithmetic exponentiation on numbers (whether integers, rationals, or reals).</p><span class="comment-delim">*)</span></div></li><li id="extension-Div" class="def extension anchored"><a href="#extension-Div" class="anchor"></a><code><span>| </span><span><span class="extension">Div</span> <span class="keyword">of</span> <span>[ `Rat <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Div:{a=(Rational|Real)} a -&gt; a -&gt; a</code>: arithmetic exact division on numbers (rationals, or reals, but **not** integers).</p><span class="comment-delim">*)</span></div></li><li id="extension-Div_e" class="def extension anchored"><a href="#extension-Div_e" class="anchor"></a><code><span>| </span><span><span class="extension">Div_e</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Div_e:{a=(Int|Rational|Real)} a -&gt; a -&gt; a</code>: arithmetic integer euclidian quotient (whether integers, rationals, or reals). If D is positive then <code>Div_e (N,D)</code> is the floor (in the type of N and D) of the real division <code>N/D</code>, and if D is negative then <code>Div_e (N,D)</code> is the ceiling of <code>N/D</code>.</p><span class="comment-delim">*)</span></div></li><li id="extension-Div_t" class="def extension anchored"><a href="#extension-Div_t" class="anchor"></a><code><span>| </span><span><span class="extension">Div_t</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Div_t:{a=(Int|Rational|Real)} a -&gt; a -&gt; a</code>: arithmetic integer truncated quotient (whether integers, rationals, or reals). <code>Div_t (N,D)</code> is the truncation of the real division <code>N/D</code>.</p><span class="comment-delim">*)</span></div></li><li id="extension-Div_f" class="def extension anchored"><a href="#extension-Div_f" class="anchor"></a><code><span>| </span><span><span class="extension">Div_f</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Div_f:{a=(Int|Rational|Real)} a -&gt; a -&gt; a</code>: arithmetic integer floor quotient (whether integers, rationals, or reals). <code>Div_t (N,D)</code> is the floor of the real division <code>N/D</code>.</p><span class="comment-delim">*)</span></div></li><li id="extension-Modulo_e" class="def extension anchored"><a href="#extension-Modulo_e" class="anchor"></a><code><span>| </span><span><span class="extension">Modulo_e</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Modulo_e:{a=(Int|Rational|Real)} a -&gt; a -&gt; a</code>: arithmetic integer euclidian remainder (whether integers, rationals, or reals). It is defined by the following equation: <code>Div_e (N, D) * D + Modulo(N, D) = N</code>.</p><span class="comment-delim">*)</span></div></li><li id="extension-Modulo_t" class="def extension anchored"><a href="#extension-Modulo_t" class="anchor"></a><code><span>| </span><span><span class="extension">Modulo_t</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Modulo_t:{a=(Int|Rational|Real)} a -&gt; a -&gt; a</code>: arithmetic integer truncated remainder (whether integers, rationals, or reals). It is defined by the following equation: <code>Div_t (N, D) * D + Modulo_t(N, D) = N</code>.</p><span class="comment-delim">*)</span></div></li><li id="extension-Modulo_f" class="def extension anchored"><a href="#extension-Modulo_f" class="anchor"></a><code><span>| </span><span><span class="extension">Modulo_f</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Modulo_f:{a=(Int|Rational|Real)} a -&gt; a -&gt; a</code>: arithmetic integer floor remainder (whether integers, rationals, or reals). It is defined by the following equation: <code>Div_f (N, D) * D + Modulo_f(N, D) = N</code>.</p><span class="comment-delim">*)</span></div></li><li id="extension-Abs" class="def extension anchored"><a href="#extension-Abs" class="anchor"></a><code><span>| </span><span><span class="extension">Abs</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Abs: Int -&gt; Int</code>: absolute value on integers.</p><span class="comment-delim">*)</span></div></li><li id="extension-Divisible" class="def extension anchored"><a href="#extension-Divisible" class="anchor"></a><code><span>| </span><span><span class="extension">Divisible</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Divisible: Int -&gt; Int -&gt; Prop</code>: divisibility predicate on integers. Smtlib restricts applications of this predicate to have a litteral integer for the divisor/second argument.</p><span class="comment-delim">*)</span></div></li><li id="extension-Is_int" class="def extension anchored"><a href="#extension-Is_int" class="anchor"></a><code><span>| </span><span><span class="extension">Is_int</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Is_int:{a=(Int|Rational|Real)} a -&gt; Prop</code>: integer predicate for numbers: is the given number an integer.</p><span class="comment-delim">*)</span></div></li><li id="extension-Is_rat" class="def extension anchored"><a href="#extension-Is_rat" class="anchor"></a><code><span>| </span><span><span class="extension">Is_rat</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Is_rat:{a=(Int|Rational|Real)} a -&gt; Prop</code>: rational predicate for numbers: is the given number an rational.</p><span class="comment-delim">*)</span></div></li><li id="extension-Floor" class="def extension anchored"><a href="#extension-Floor" class="anchor"></a><code><span>| </span><span><span class="extension">Floor</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Floor:{a=(Int|Rational|Real)} a -&gt; a</code>: floor function on numbers, defined in tptp as the largest integer not greater than the argument.</p><span class="comment-delim">*)</span></div></li><li id="extension-Floor_to_int" class="def extension anchored"><a href="#extension-Floor_to_int" class="anchor"></a><code><span>| </span><span><span class="extension">Floor_to_int</span> <span class="keyword">of</span> <span>[ `Rat <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Floor_to_int:{a=(Rational|Real)} a -&gt; Int</code>: floor and conversion to integers in a single function. Should return the greatest integer <code>i</code> such that the rational or real intepretation of <code>i</code> is less than, or equal to, the argument.</p><span class="comment-delim">*)</span></div></li><li id="extension-Ceiling" class="def extension anchored"><a href="#extension-Ceiling" class="anchor"></a><code><span>| </span><span><span class="extension">Ceiling</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Ceiling:{a=(Int|Rational|Real)} a -&gt; a</code>: ceiling function on numbers, defined in tptp as the smallest integer not less than the argument.</p><span class="comment-delim">*)</span></div></li><li id="extension-Truncate" class="def extension anchored"><a href="#extension-Truncate" class="anchor"></a><code><span>| </span><span><span class="extension">Truncate</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Truncate:{a=(Int|Rational|Real)} a -&gt; a</code>: ceiling function on numbers, defined in tptp as the nearest integer value with magnitude not greater than the absolute value of the argument.</p><span class="comment-delim">*)</span></div></li><li id="extension-Round" class="def extension anchored"><a href="#extension-Round" class="anchor"></a><code><span>| </span><span><span class="extension">Round</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Round:{a=(Int|Rational|Real)} a -&gt; a</code>: rounding function on numbers, defined in tptp as the nearest intger to the argument; when the argument is halfway between two integers, the nearest even integer to the argument.</p><span class="comment-delim">*)</span></div></li></ol></div></div><h3 id="arrays-builtins"><a href="#arrays-builtins" class="anchor"></a>Arrays Builtins</h3><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Array"><a href="#extension-decl-Array" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Array" class="def extension anchored"><a href="#extension-Array" class="anchor"></a><code><span>| </span><span><span class="extension">Array</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Array: ttype -&gt; ttype -&gt; ttype</code>: the type constructor for polymorphic functional arrays. An <code>(src, dst) Array</code> is an array from expressions of type <code>src</code> to expressions of type <code>dst</code>. Typically, such arrays are immutables.</p><span class="comment-delim">*)</span></div></li><li id="extension-Const" class="def extension anchored"><a href="#extension-Const" class="anchor"></a><code><span>| </span><span><span class="extension">Const</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Store: 'a 'b. 'b -&gt; ('a, 'b) Array</code>: returns a constant array, which maps any value of type <code>'a</code> to the given base value.</p><span class="comment-delim">*)</span></div></li><li id="extension-Store" class="def extension anchored"><a href="#extension-Store" class="anchor"></a><code><span>| </span><span><span class="extension">Store</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Store: 'a 'b. ('a, 'b) Array -&gt; 'a -&gt; 'b -&gt; ('a, 'b) Array</code>: store operation on arrays. Returns a new array with the key bound to the given value (shadowing the previous value associated to the key).</p><span class="comment-delim">*)</span></div></li><li id="extension-Select" class="def extension anchored"><a href="#extension-Select" class="anchor"></a><code><span>| </span><span><span class="extension">Select</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Select: 'a 'b. ('a, 'b) Array -&gt; 'a -&gt; 'b</code>: select operation on arrays. Returns the value associated to the given key. Typically, functional arrays are complete, i.e. all keys are mapped to a value.</p><span class="comment-delim">*)</span></div></li></ol></div></div><h3 id="bitvectors-builtins"><a href="#bitvectors-builtins" class="anchor"></a>Bitvectors Builtins</h3><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Bitv"><a href="#extension-decl-Bitv" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Bitv" class="def extension anchored"><a href="#extension-Bitv" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv n: ttype</code>: type constructor for bitvectors of length <code>n</code>.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitvec" class="def extension anchored"><a href="#extension-Bitvec" class="anchor"></a><code><span>| </span><span><span class="extension">Bitvec</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitvec s: Bitv</code>: bitvector litteral. The string <code>s</code> should be a binary representation of bitvectors using characters <code>'0'</code>, and <code>'1'</code> (lsb last)</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_concat" class="def extension anchored"><a href="#extension-Bitv_concat" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_concat</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="module-Builtin.n" class="def record field anchored"><a href="#module-Builtin.n" class="anchor"></a><code><span>n : int;</span></code></li><li id="module-Builtin.m" class="def record field anchored"><a href="#module-Builtin.m" class="anchor"></a><code><span>m : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_concat(n,m): Bitv(n) -&gt; Bitv(m) -&gt; Bitv(n+m)</code>: concatenation operator on bitvectors.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_extract" class="def extension anchored"><a href="#extension-Bitv_extract" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_extract</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="module-Builtin.n" class="def record field anchored"><a href="#module-Builtin.n" class="anchor"></a><code><span>n : int;</span></code></li><li id="module-Builtin.i" class="def record field anchored"><a href="#module-Builtin.i" class="anchor"></a><code><span>i : int;</span></code></li><li id="module-Builtin.j" class="def record field anchored"><a href="#module-Builtin.j" class="anchor"></a><code><span>j : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_extract(n, i, j): Bitv(n) -&gt; Bitv(i - j + 1)</code>: bitvector extraction, from index <code>j</code> up to <code>i</code> (both included).</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_repeat" class="def extension anchored"><a href="#extension-Bitv_repeat" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_repeat</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="module-Builtin.n" class="def record field anchored"><a href="#module-Builtin.n" class="anchor"></a><code><span>n : int;</span></code></li><li id="module-Builtin.k" class="def record field anchored"><a href="#module-Builtin.k" class="anchor"></a><code><span>k : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_repeat(n,k): Bitv(n) -&gt; Bitv(n*k)</code>: bitvector repeatition.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_zero_extend" class="def extension anchored"><a href="#extension-Bitv_zero_extend" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_zero_extend</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="module-Builtin.n" class="def record field anchored"><a href="#module-Builtin.n" class="anchor"></a><code><span>n : int;</span></code></li><li id="module-Builtin.k" class="def record field anchored"><a href="#module-Builtin.k" class="anchor"></a><code><span>k : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_zero_extend(n,k): Bitv(n) -&gt; Bitv(n + k)</code>: zero extension for bitvectors (produces a representation of the same unsigned integer).</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_sign_extend" class="def extension anchored"><a href="#extension-Bitv_sign_extend" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_sign_extend</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="module-Builtin.n" class="def record field anchored"><a href="#module-Builtin.n" class="anchor"></a><code><span>n : int;</span></code></li><li id="module-Builtin.k" class="def record field anchored"><a href="#module-Builtin.k" class="anchor"></a><code><span>k : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_sign_extend(n,k): Bitv(n) -&gt; Bitv(n + k)</code>: sign extension for bitvectors ((produces a representation of the same signed integer).</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_rotate_right" class="def extension anchored"><a href="#extension-Bitv_rotate_right" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_rotate_right</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="module-Builtin.n" class="def record field anchored"><a href="#module-Builtin.n" class="anchor"></a><code><span>n : int;</span></code></li><li id="module-Builtin.i" class="def record field anchored"><a href="#module-Builtin.i" class="anchor"></a><code><span>i : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_rotate_right(n,i): Bitv(n) -&gt; Bitv(n)</code>: logical rotate right for bitvectors by <code>i</code>.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_rotate_left" class="def extension anchored"><a href="#extension-Bitv_rotate_left" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_rotate_left</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="module-Builtin.n" class="def record field anchored"><a href="#module-Builtin.n" class="anchor"></a><code><span>n : int;</span></code></li><li id="module-Builtin.i" class="def record field anchored"><a href="#module-Builtin.i" class="anchor"></a><code><span>i : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_rotate_left(n,i): Bitv(n) -&gt; Bitv(n)</code>: logical rotate left for bitvectors by <code>i</code>.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_not" class="def extension anchored"><a href="#extension-Bitv_not" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_not</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_not(n): Bitv(n) -&gt; Bitv(n)</code>: bitwise negation for bitvectors.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_and" class="def extension anchored"><a href="#extension-Bitv_and" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_and</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_and(n): Bitv(n) -&gt; Bitv(n) -&gt; Bitv(n)</code>: bitwise conjunction for bitvectors.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_or" class="def extension anchored"><a href="#extension-Bitv_or" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_or</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>bitv_or(n): Bitv(n) -&gt; Bitv(n) -&gt; Bitv(n)</code>: bitwise disjunction for bitvectors.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_nand" class="def extension anchored"><a href="#extension-Bitv_nand" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_nand</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_nand(n): Bitv(n) -&gt; Bitv(n) -&gt; Bitv(n)</code>: bitwise negated conjunction for bitvectors. <code>Bitv_nand s t</code> abbreviates <code>Bitv_not (Bitv_and s t))</code>.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_nor" class="def extension anchored"><a href="#extension-Bitv_nor" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_nor</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_nor(n): Bitv(n) -&gt; Bitv(n) -&gt; Bitv(n)</code>: bitwise negated disjunction for bitvectors. <code>Bitv_nor s t</code> abbreviates <code>Bitv_not (Bitv_or s t))</code>.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_xor" class="def extension anchored"><a href="#extension-Bitv_xor" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_xor</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_xor(n): Bitv(n) -&gt; Bitv(n) -&gt; Bitv(n)</code>: bitwise exclusive disjunction for bitvectors. <code>Bitv_xor s t</code> abbreviates <code>Bitv_or (Bitv_and s (Bitv_not t))
               (Bitv_and (Bitv_not s) t) </code>.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_xnor" class="def extension anchored"><a href="#extension-Bitv_xnor" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_xnor</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_xnor(n): Bitv(n) -&gt; Bitv(n) -&gt; Bitv(n)</code>: bitwise negated exclusive disjunction for bitvectors. <code>Bitv_xnor s t</code> abbreviates <code>Bitv_or (Bitv_and s t)
               (Bitv_and (Bitv_not s) (Bitv_not t))</code>.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_comp" class="def extension anchored"><a href="#extension-Bitv_comp" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_comp</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_comp(n): Bitv(n) -&gt; Bitv(n) -&gt; Bitv(1)</code>: Returns the constant bitvector <code>&quot;1&quot;</code> is all bits are equal, and the bitvector <code>&quot;0&quot;</code> if not.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_neg" class="def extension anchored"><a href="#extension-Bitv_neg" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_neg</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_neg(n): Bitv(n) -&gt; Bitv(n)</code>: 2's complement unary minus.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_add" class="def extension anchored"><a href="#extension-Bitv_add" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_add</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_add(n): Bitv(n) -&gt; Bitv(n) -&gt; Bitv(n)</code>: addition modulo 2^n.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_sub" class="def extension anchored"><a href="#extension-Bitv_sub" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_sub</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_sub(n): Bitv(n) -&gt; Bitv(n) -&gt; Bitv(n)</code>: 2's complement subtraction modulo 2^n.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_mul" class="def extension anchored"><a href="#extension-Bitv_mul" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_mul</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_mul(n): Bitv(n) -&gt; Bitv(n) -&gt; Bitv(n)</code>: multiplication modulo 2^n.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_udiv" class="def extension anchored"><a href="#extension-Bitv_udiv" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_udiv</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_udiv(n): Bitv(n) -&gt; Bitv(n) -&gt; Bitv(n)</code>: unsigned division, truncating towards 0.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_urem" class="def extension anchored"><a href="#extension-Bitv_urem" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_urem</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_urem(n): Bitv(n) -&gt; Bitv(n) -&gt; Bitv(n)</code>: unsigned remainder from truncating division.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_sdiv" class="def extension anchored"><a href="#extension-Bitv_sdiv" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_sdiv</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_sdiv(n): Bitv(n) -&gt; Bitv(n) -&gt; Bitv(n)</code>: 2's complement signed division.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_srem" class="def extension anchored"><a href="#extension-Bitv_srem" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_srem</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_srem(n): Bitv(n) -&gt; Bitv(n) -&gt; Bitv(n)</code>: 2's complement signed remainder (sign follows dividend).</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_smod" class="def extension anchored"><a href="#extension-Bitv_smod" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_smod</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_smod(n): Bitv(n) -&gt; Bitv(n) -&gt; Bitv(n)</code>: 2's complement signed remainder (sign follows divisor).</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_shl" class="def extension anchored"><a href="#extension-Bitv_shl" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_shl</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_shl(n): Bitv(n) -&gt; Bitv(n) -&gt; Bitv(n)</code>: shift left (equivalent to multiplication by 2^x where x is the value of the second argument).</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_lshr" class="def extension anchored"><a href="#extension-Bitv_lshr" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_lshr</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_lshr(n): Bitv(n) -&gt; Bitv(n) -&gt; Bitv(n)</code>: logical shift right (equivalent to unsigned division by 2^x, where x is the value of the second argument).</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_ashr" class="def extension anchored"><a href="#extension-Bitv_ashr" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_ashr</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_ashr(n): Bitv(n) -&gt; Bitv(n) -&gt; Bitv(n)</code>: Arithmetic shift right, like logical shift right except that the most significant bits of the result always copy the most significant bit of the first argument.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_ult" class="def extension anchored"><a href="#extension-Bitv_ult" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_ult</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_ult(n): Bitv(n) -&gt; Bitv(n) -&gt; Prop</code>: binary predicate for unsigned less-than.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_ule" class="def extension anchored"><a href="#extension-Bitv_ule" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_ule</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_ule(n): Bitv(n) -&gt; Bitv(n) -&gt; Prop</code>: binary predicate for unsigned less than or equal.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_ugt" class="def extension anchored"><a href="#extension-Bitv_ugt" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_ugt</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_ugt(n): Bitv(n) -&gt; Bitv(n) -&gt; Prop</code>: binary predicate for unsigned greater-than.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_uge" class="def extension anchored"><a href="#extension-Bitv_uge" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_uge</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_uge(n): Bitv(n) -&gt; Bitv(n) -&gt; Prop</code>: binary predicate for unsigned greater than or equal.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_slt" class="def extension anchored"><a href="#extension-Bitv_slt" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_slt</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_slt(n): Bitv(n) -&gt; Bitv(n) -&gt; Prop</code>: binary predicate for signed less-than.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_sle" class="def extension anchored"><a href="#extension-Bitv_sle" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_sle</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_sle(n): Bitv(n) -&gt; Bitv(n) -&gt; Prop</code>: binary predicate for signed less than or equal.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_sgt" class="def extension anchored"><a href="#extension-Bitv_sgt" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_sgt</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_sgt(n): Bitv(n) -&gt; Bitv(n) -&gt; Prop</code>: binary predicate for signed greater-than.</p><span class="comment-delim">*)</span></div></li><li id="extension-Bitv_sge" class="def extension anchored"><a href="#extension-Bitv_sge" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv_sge</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv_sge(n): Bitv(n) -&gt; Bitv(n) -&gt; Prop</code>: binary predicate for signed greater than or equal.</p><span class="comment-delim">*)</span></div></li></ol></div></div><h3 id="floats-builtins"><a href="#floats-builtins" class="anchor"></a>Floats Builtins</h3><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-RoundingMode"><a href="#extension-decl-RoundingMode" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-RoundingMode" class="def extension anchored"><a href="#extension-RoundingMode" class="anchor"></a><code><span>| </span><span><span class="extension">RoundingMode</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>RoundingMode: ttype</code>: type for enumerated type of rounding modes.</p><span class="comment-delim">*)</span></div></li><li id="extension-RoundNearestTiesToEven" class="def extension anchored"><a href="#extension-RoundNearestTiesToEven" class="anchor"></a><code><span>| </span><span><span class="extension">RoundNearestTiesToEven</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>RoundNearestTiesToEven : RoundingMode</code>:</p><span class="comment-delim">*)</span></div></li><li id="extension-RoundNearestTiesToAway" class="def extension anchored"><a href="#extension-RoundNearestTiesToAway" class="anchor"></a><code><span>| </span><span><span class="extension">RoundNearestTiesToAway</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>RoundNearestTiesToAway : RoundingMode</code>:</p><span class="comment-delim">*)</span></div></li><li id="extension-RoundTowardPositive" class="def extension anchored"><a href="#extension-RoundTowardPositive" class="anchor"></a><code><span>| </span><span><span class="extension">RoundTowardPositive</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>RoundTowardPositive : RoundingMode </code></p><span class="comment-delim">*)</span></div></li><li id="extension-RoundTowardNegative" class="def extension anchored"><a href="#extension-RoundTowardNegative" class="anchor"></a><code><span>| </span><span><span class="extension">RoundTowardNegative</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>RoundTowardNegative : RoundingMode </code></p><span class="comment-delim">*)</span></div></li><li id="extension-RoundTowardZero" class="def extension anchored"><a href="#extension-RoundTowardZero" class="anchor"></a><code><span>| </span><span><span class="extension">RoundTowardZero</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>RoundTowardZero : RoundingMode </code></p><span class="comment-delim">*)</span></div></li><li id="extension-Float" class="def extension anchored"><a href="#extension-Float" class="anchor"></a><code><span>| </span><span><span class="extension">Float</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Float(e,s): ttype</code>: type constructor for floating point of exponent of size <code>e</code> and significand of size <code>s</code> (hidden bit included). Those size are greater than 1</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp" class="def extension anchored"><a href="#extension-Fp" class="anchor"></a><code><span>| </span><span><span class="extension">Fp</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp(e, s): Bitv(1) -&gt; Bitv(e) -&gt; Bitv(s-1) -&gt; Fp(e,s)</code>: bitvector literal. The IEEE-format is used for the conversion <code>sb^se^ss</code>. All the NaN are converted to the same value.</p><span class="comment-delim">*)</span></div></li><li id="extension-Plus_infinity" class="def extension anchored"><a href="#extension-Plus_infinity" class="anchor"></a><code><span>| </span><span><span class="extension">Plus_infinity</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Plus_infinity(s,e) : Fp(s,e)</code></p><span class="comment-delim">*)</span></div></li><li id="extension-Minus_infinity" class="def extension anchored"><a href="#extension-Minus_infinity" class="anchor"></a><code><span>| </span><span><span class="extension">Minus_infinity</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Minus_infinity(s,e) : Fp(s,e)</code></p><span class="comment-delim">*)</span></div></li><li id="extension-Plus_zero" class="def extension anchored"><a href="#extension-Plus_zero" class="anchor"></a><code><span>| </span><span><span class="extension">Plus_zero</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Plus_zero(s,e) : Fp(s,e)</code></p><span class="comment-delim">*)</span></div></li><li id="extension-Minus_zero" class="def extension anchored"><a href="#extension-Minus_zero" class="anchor"></a><code><span>| </span><span><span class="extension">Minus_zero</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Minus_zero(s,e) : Fp(s,e)</code></p><span class="comment-delim">*)</span></div></li><li id="extension-NaN" class="def extension anchored"><a href="#extension-NaN" class="anchor"></a><code><span>| </span><span><span class="extension">NaN</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>NaN(s,e) : Fp(s,e)</code></p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_abs" class="def extension anchored"><a href="#extension-Fp_abs" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_abs</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_abs(s,e): Fp(s,e) -&gt; Fp(s,e)</code>: absolute value</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_neg" class="def extension anchored"><a href="#extension-Fp_neg" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_neg</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_neg(s,e): Fp(s,e) -&gt; Fp(s,e)</code>: negation</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_add" class="def extension anchored"><a href="#extension-Fp_add" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_add</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_add(s,e): RoundingMode -&gt; Fp(s,e) -&gt; Fp(s,e) -&gt; Fp(s,e)</code>: addition</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_sub" class="def extension anchored"><a href="#extension-Fp_sub" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_sub</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_sub(s,e): RoundingMode -&gt; Fp(s,e) -&gt; Fp(s,e) -&gt; Fp(s,e)</code>: subtraction</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_mul" class="def extension anchored"><a href="#extension-Fp_mul" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_mul</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_mul(s,e): RoundingMode -&gt; Fp(s,e) -&gt; Fp(s,e) -&gt; Fp(s,e)</code>: multiplication</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_div" class="def extension anchored"><a href="#extension-Fp_div" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_div</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_div(s,e): RoundingMode -&gt; Fp(s,e) -&gt; Fp(s,e) -&gt; Fp(s,e)</code>: division</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_fma" class="def extension anchored"><a href="#extension-Fp_fma" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_fma</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_fma(s,e): RoundingMode -&gt; Fp(s,e) -&gt; Fp(s,e)</code>: fuse multiply add</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_sqrt" class="def extension anchored"><a href="#extension-Fp_sqrt" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_sqrt</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_sqrt(s,e): RoundingMode -&gt; Fp(s,e) -&gt; Fp(s,e)</code>: square root</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_rem" class="def extension anchored"><a href="#extension-Fp_rem" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_rem</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_rem(s,e): Fp(s,e) -&gt; Fp(s,e) -&gt; Fp(s,e)</code>: remainder</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_roundToIntegral" class="def extension anchored"><a href="#extension-Fp_roundToIntegral" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_roundToIntegral</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_roundToIntegral(s,e): RoundingMode -&gt; Fp(s,e) -&gt; Fp(s,e)</code>: round to integral</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_min" class="def extension anchored"><a href="#extension-Fp_min" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_min</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_min(s,e): Fp(s,e) -&gt; Fp(s,e) -&gt; Fp(s,e)</code>: minimum</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_max" class="def extension anchored"><a href="#extension-Fp_max" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_max</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_max(s,e): Fp(s,e) -&gt; Fp(s,e) -&gt; Fp(s,e)</code>: maximum</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_leq" class="def extension anchored"><a href="#extension-Fp_leq" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_leq</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_leq(s,e): Fp(s,e) -&gt; Fp(s,e) -&gt; Prop</code>: IEEE less or equal</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_lt" class="def extension anchored"><a href="#extension-Fp_lt" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_lt</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_lt(s,e): Fp(s,e) -&gt; Fp(s,e) -&gt; Prop</code>: IEEE less than</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_geq" class="def extension anchored"><a href="#extension-Fp_geq" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_geq</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_geq(s,e): Fp(s,e) -&gt; Fp(s,e) -&gt; Prop</code>: IEEE greater or equal</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_gt" class="def extension anchored"><a href="#extension-Fp_gt" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_gt</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_gt(s,e): Fp(s,e) -&gt; Fp(s,e) -&gt; Prop</code>: IEEE greater than</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_eq" class="def extension anchored"><a href="#extension-Fp_eq" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_eq</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_eq(s,e): Fp(s,e) -&gt; Fp(s,e) -&gt; Prop</code>: IEEE equality</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_isNormal" class="def extension anchored"><a href="#extension-Fp_isNormal" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_isNormal</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_isNormal(s,e): Fp(s,e) -&gt; Prop</code>: test if it is a normal floating point</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_isSubnormal" class="def extension anchored"><a href="#extension-Fp_isSubnormal" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_isSubnormal</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_isSubnormal(s,e): Fp(s,e) -&gt; Prop</code>: test if it is a subnormal floating point</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_isZero" class="def extension anchored"><a href="#extension-Fp_isZero" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_isZero</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_isZero(s,e): Fp(s,e) -&gt; Prop</code>: test if it is a zero</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_isInfinite" class="def extension anchored"><a href="#extension-Fp_isInfinite" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_isInfinite</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_isInfinite(s,e): Fp(s,e) -&gt; Prop</code>: test if it is an infinite</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_isNaN" class="def extension anchored"><a href="#extension-Fp_isNaN" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_isNaN</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_isNaN(s,e): Fp(s,e) -&gt; Prop</code>: test if it is Not a Number</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_isNegative" class="def extension anchored"><a href="#extension-Fp_isNegative" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_isNegative</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_isNegative(s,e): Fp(s,e) -&gt; Prop</code>: test if it is negative</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_isPositive" class="def extension anchored"><a href="#extension-Fp_isPositive" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_isPositive</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_isPositive(s,e): Fp(s,e) -&gt; Prop</code>: test if it is positive</p><span class="comment-delim">*)</span></div></li><li id="extension-Ieee_format_to_fp" class="def extension anchored"><a href="#extension-Ieee_format_to_fp" class="anchor"></a><code><span>| </span><span><span class="extension">Ieee_format_to_fp</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Ieee_format_to_fp(s,e): Bv(s+e) -&gt; Fp(s,e)</code>: Convert from IEEE interchange format</p><span class="comment-delim">*)</span></div></li><li id="extension-Fp_to_fp" class="def extension anchored"><a href="#extension-Fp_to_fp" class="anchor"></a><code><span>| </span><span><span class="extension">Fp_to_fp</span> <span class="keyword">of</span> int * int * int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Fp_to_fp(s1,e1,s2,e2): RoundingMode -&gt; Fp(s1,e1) -&gt; Fp(s2,e2)</code>: Convert from another floating point format</p><span class="comment-delim">*)</span></div></li><li id="extension-Real_to_fp" class="def extension anchored"><a href="#extension-Real_to_fp" class="anchor"></a><code><span>| </span><span><span class="extension">Real_to_fp</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Real_to_fp(s,e): RoundingMode -&gt; Real -&gt; Fp(s,e)</code>: Convert from a real</p><span class="comment-delim">*)</span></div></li><li id="extension-Sbv_to_fp" class="def extension anchored"><a href="#extension-Sbv_to_fp" class="anchor"></a><code><span>| </span><span><span class="extension">Sbv_to_fp</span> <span class="keyword">of</span> int * int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Sbv_to_fp(m,s,e): RoundingMode -&gt; Bitv(m) -&gt; Fp(s,e)</code>: Convert from a signed integer</p><span class="comment-delim">*)</span></div></li><li id="extension-Ubv_to_fp" class="def extension anchored"><a href="#extension-Ubv_to_fp" class="anchor"></a><code><span>| </span><span><span class="extension">Ubv_to_fp</span> <span class="keyword">of</span> int * int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Ubv_to_fp(m,s,e): RoundingMode -&gt; Bitv(m) -&gt; Fp(s,e)</code>: Convert from a unsigned integer</p><span class="comment-delim">*)</span></div></li><li id="extension-To_ubv" class="def extension anchored"><a href="#extension-To_ubv" class="anchor"></a><code><span>| </span><span><span class="extension">To_ubv</span> <span class="keyword">of</span> int * int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>To_ubv(s,e,m): RoundingMode -&gt; Fp(s,e) -&gt; Bitv(m)</code>: Convert to an unsigned integer</p><span class="comment-delim">*)</span></div></li><li id="extension-To_sbv" class="def extension anchored"><a href="#extension-To_sbv" class="anchor"></a><code><span>| </span><span><span class="extension">To_sbv</span> <span class="keyword">of</span> int * int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>To_ubv(s,e,m): RoundingMode -&gt; Fp(s,e) -&gt; Bitv(m)</code>: Convert to an signed integer</p><span class="comment-delim">*)</span></div></li><li id="extension-To_real" class="def extension anchored"><a href="#extension-To_real" class="anchor"></a><code><span>| </span><span><span class="extension">To_real</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>To_real(s,e): Fp(s,e) -&gt; Real</code>: Convert to real</p><span class="comment-delim">*)</span></div></li></ol></div></div><h3 id="string-and-regexp-builtins"><a href="#string-and-regexp-builtins" class="anchor"></a>String and Regexp Builtins</h3><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-String"><a href="#extension-decl-String" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-String" class="def extension anchored"><a href="#extension-String" class="anchor"></a><code><span>| </span><span><span class="extension">String</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>String: ttype</code>: type constructor for strings.</p><span class="comment-delim">*)</span></div></li><li id="extension-Str" class="def extension anchored"><a href="#extension-Str" class="anchor"></a><code><span>| </span><span><span class="extension">Str</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Str s: String</code>: string literals.</p><span class="comment-delim">*)</span></div></li><li id="extension-Str_length" class="def extension anchored"><a href="#extension-Str_length" class="anchor"></a><code><span>| </span><span><span class="extension">Str_length</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Str_length: String -&gt; Int</code>: string length.</p><span class="comment-delim">*)</span></div></li><li id="extension-Str_at" class="def extension anchored"><a href="#extension-Str_at" class="anchor"></a><code><span>| </span><span><span class="extension">Str_at</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Str_at: String -&gt; Int -&gt; String</code>: Singleton string containing a character at given position or empty string when position is out of range. The leftmost position is 0.</p><span class="comment-delim">*)</span></div></li><li id="extension-Str_to_code" class="def extension anchored"><a href="#extension-Str_to_code" class="anchor"></a><code><span>| </span><span><span class="extension">Str_to_code</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Str_to_code: String -&gt; Int</code>: <code>Str_to_code s</code> is the code point of the only character of s, if s is a singleton string; otherwise, it is -1.</p><span class="comment-delim">*)</span></div></li><li id="extension-Str_of_code" class="def extension anchored"><a href="#extension-Str_of_code" class="anchor"></a><code><span>| </span><span><span class="extension">Str_of_code</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Str_of_code: Int -&gt; String</code>: <code>Str_of_code n</code> is the singleton string whose only character is code point n if n is in the range <code>0, 196607</code>; otherwise, it is the empty string.</p><span class="comment-delim">*)</span></div></li><li id="extension-Str_is_digit" class="def extension anchored"><a href="#extension-Str_is_digit" class="anchor"></a><code><span>| </span><span><span class="extension">Str_is_digit</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Str_is_digit: String -&gt; Prop</code>: Digit check <code>Str.is_digit s</code> is true iff s consists of a single character which is a decimal digit, that is, a code point in the range 0x0030 ... 0x0039.</p><span class="comment-delim">*)</span></div></li><li id="extension-Str_to_int" class="def extension anchored"><a href="#extension-Str_to_int" class="anchor"></a><code><span>| </span><span><span class="extension">Str_to_int</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Str_to_int: String -&gt; Int</code>: Conversion to integers <code>Str.to_int s</code> with s consisting of digits (in the sense of str.is_digit) evaluates to the positive integer denoted by s when seen as a number in base 10 (possibly with leading zeros). It evaluates to -1 if s is empty or contains non-digits.</p><span class="comment-delim">*)</span></div></li><li id="extension-Str_of_int" class="def extension anchored"><a href="#extension-Str_of_int" class="anchor"></a><code><span>| </span><span><span class="extension">Str_of_int</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Str_of_int : Int -&gt; String</code>: Conversion from integers. <code>Str.from_int n</code> with n non-negative is the corresponding string in decimal notation, with no leading zeros. If n &lt; 0, it is the empty string.</p><span class="comment-delim">*)</span></div></li><li id="extension-Str_concat" class="def extension anchored"><a href="#extension-Str_concat" class="anchor"></a><code><span>| </span><span><span class="extension">Str_concat</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Str_concat: String -&gt; String -&gt; String</code>: string concatenation.</p><span class="comment-delim">*)</span></div></li><li id="extension-Str_sub" class="def extension anchored"><a href="#extension-Str_sub" class="anchor"></a><code><span>| </span><span><span class="extension">Str_sub</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Str_sub: String -&gt; Int -&gt; Int -&gt; String</code>: <code>Str_sub s i n</code> evaluates to the longest (unscattered) substring of s of length at most n starting at position i. It evaluates to the empty string if n is negative or i is not in the interval <code>0,l-1</code> where l is the length of s.</p><span class="comment-delim">*)</span></div></li><li id="extension-Str_index_of" class="def extension anchored"><a href="#extension-Str_index_of" class="anchor"></a><code><span>| </span><span><span class="extension">Str_index_of</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Str_index_of: String -&gt; String -&gt; Int -&gt; Int</code>: Index of first occurrence of second string in first one starting at the position specified by the third argument. <code>Str_index_of s t i</code>, with 0 &lt;= i &lt;= |s| is the position of the first occurrence of t in s at or after position i, if any. Otherwise, it is -1. Note that the result is i whenever i is within the range <code>0, |s|</code> and t is empty.</p><span class="comment-delim">*)</span></div></li><li id="extension-Str_replace" class="def extension anchored"><a href="#extension-Str_replace" class="anchor"></a><code><span>| </span><span><span class="extension">Str_replace</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Str_replace: String -&gt; String -&gt; String -&gt; String</code>: Replace <code>Str_replace s t t'</code> is the string obtained by replacing the first occurrence of t in s, if any, by t'. Note that if t is empty, the result is to prepend t' to s; also, if t does not occur in s then the result is s.</p><span class="comment-delim">*)</span></div></li><li id="extension-Str_replace_all" class="def extension anchored"><a href="#extension-Str_replace_all" class="anchor"></a><code><span>| </span><span><span class="extension">Str_replace_all</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Str_replace_all: String -&gt; String -&gt; String -&gt; String</code>: <code>Str_replace_all s t t’</code> is s if t is the empty string. Otherwise, it is the string obtained from s by replacing all occurrences of t in s by t’, starting with the first occurrence and proceeding in left-to-right order.</p><span class="comment-delim">*)</span></div></li><li id="extension-Str_replace_re" class="def extension anchored"><a href="#extension-Str_replace_re" class="anchor"></a><code><span>| </span><span><span class="extension">Str_replace_re</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Str_replace_re: String -&gt; String_RegLan -&gt; String -&gt; String</code>: <code>Str_replace_re s r t</code> is the string obtained by replacing the shortest leftmost non-empty match of r in s, if any, by t. Note that if t is empty, the result is to prepend t to s.</p><span class="comment-delim">*)</span></div></li><li id="extension-Str_replace_re_all" class="def extension anchored"><a href="#extension-Str_replace_re_all" class="anchor"></a><code><span>| </span><span><span class="extension">Str_replace_re_all</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Str_replace_re_all: String -&gt; String_RegLan -&gt; String -&gt; String</code>: <code>Str_replace_re_all s r t</code> is the string obtained by replacing, left-to right, each shortest *non-empty* match of r in s by t.</p><span class="comment-delim">*)</span></div></li><li id="extension-Str_is_prefix" class="def extension anchored"><a href="#extension-Str_is_prefix" class="anchor"></a><code><span>| </span><span><span class="extension">Str_is_prefix</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Str_is_prefix: String -&gt; String -&gt; Prop</code>: Prefix check <code>Str_is_prefix s t</code> is true iff s is a prefix of t.</p><span class="comment-delim">*)</span></div></li><li id="extension-Str_is_suffix" class="def extension anchored"><a href="#extension-Str_is_suffix" class="anchor"></a><code><span>| </span><span><span class="extension">Str_is_suffix</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Str_is_suffix: String -&gt; String -&gt; Prop</code>: Suffix check <code>Str_is_suffix s t</code> is true iff s is a suffix of t.</p><span class="comment-delim">*)</span></div></li><li id="extension-Str_contains" class="def extension anchored"><a href="#extension-Str_contains" class="anchor"></a><code><span>| </span><span><span class="extension">Str_contains</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Str_contains: String -&gt; String -&gt; Prop</code>: Inclusion check <code>Str_contains s t</code> is true iff s contains t.</p><span class="comment-delim">*)</span></div></li><li id="extension-Str_lexicographic_strict" class="def extension anchored"><a href="#extension-Str_lexicographic_strict" class="anchor"></a><code><span>| </span><span><span class="extension">Str_lexicographic_strict</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Str_lexicographic_strict: String -&gt; String -&gt; Prop</code>: lexicographic ordering (strict).</p><span class="comment-delim">*)</span></div></li><li id="extension-Str_lexicographic_large" class="def extension anchored"><a href="#extension-Str_lexicographic_large" class="anchor"></a><code><span>| </span><span><span class="extension">Str_lexicographic_large</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Str_lexicographic_large: String -&gt; String -&gt; Prop</code>: reflexive closure of the lexicographic ordering.</p><span class="comment-delim">*)</span></div></li><li id="extension-Str_in_re" class="def extension anchored"><a href="#extension-Str_in_re" class="anchor"></a><code><span>| </span><span><span class="extension">Str_in_re</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Str_in_re: String -&gt; String_RegLan -&gt; Prop</code>: set membership.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-String_RegLan"><a href="#extension-decl-String_RegLan" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-String_RegLan" class="def extension anchored"><a href="#extension-String_RegLan" class="anchor"></a><code><span>| </span><span><span class="extension">String_RegLan</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>String_RegLan: ttype</code>: type constructor for Regular languages over strings.</p><span class="comment-delim">*)</span></div></li><li id="extension-Re_empty" class="def extension anchored"><a href="#extension-Re_empty" class="anchor"></a><code><span>| </span><span><span class="extension">Re_empty</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_empty: String_RegLan</code>: the empty language.</p><span class="comment-delim">*)</span></div></li><li id="extension-Re_all" class="def extension anchored"><a href="#extension-Re_all" class="anchor"></a><code><span>| </span><span><span class="extension">Re_all</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_all: String_RegLan</code>: the language of all strings.</p><span class="comment-delim">*)</span></div></li><li id="extension-Re_allchar" class="def extension anchored"><a href="#extension-Re_allchar" class="anchor"></a><code><span>| </span><span><span class="extension">Re_allchar</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_allchar: String_RegLan</code>: the language of all singleton strings.</p><span class="comment-delim">*)</span></div></li><li id="extension-Re_of_string" class="def extension anchored"><a href="#extension-Re_of_string" class="anchor"></a><code><span>| </span><span><span class="extension">Re_of_string</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_of_string: String -&gt; String_RegLan</code>: the singleton language with a single string.</p><span class="comment-delim">*)</span></div></li><li id="extension-Re_range" class="def extension anchored"><a href="#extension-Re_range" class="anchor"></a><code><span>| </span><span><span class="extension">Re_range</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_range: String -&gt; String -&gt; String_RegLan</code>: Language range <code>Re_range s1 s2</code> is the set of all *singleton* strings <code>s</code> such that <code>Str_lexicographic_large s1 s s2</code> provided <code>s1</code> and <code>s1</code> are singleton. Otherwise, it is the empty language.</p><span class="comment-delim">*)</span></div></li><li id="extension-Re_concat" class="def extension anchored"><a href="#extension-Re_concat" class="anchor"></a><code><span>| </span><span><span class="extension">Re_concat</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_concat: String_RegLan -&gt; String_RegLan -&gt; String_RegLan</code>: language concatenation.</p><span class="comment-delim">*)</span></div></li><li id="extension-Re_union" class="def extension anchored"><a href="#extension-Re_union" class="anchor"></a><code><span>| </span><span><span class="extension">Re_union</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_union: String_RegLan -&gt; String_RegLan -&gt; String_RegLan</code>: language union.</p><span class="comment-delim">*)</span></div></li><li id="extension-Re_inter" class="def extension anchored"><a href="#extension-Re_inter" class="anchor"></a><code><span>| </span><span><span class="extension">Re_inter</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_inter: String_RegLan -&gt; String_RegLan -&gt; String_RegLan</code>: language intersection.</p><span class="comment-delim">*)</span></div></li><li id="extension-Re_star" class="def extension anchored"><a href="#extension-Re_star" class="anchor"></a><code><span>| </span><span><span class="extension">Re_star</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_star: String_RegLan -&gt; String_RegLan</code>: Kleen star.</p><span class="comment-delim">*)</span></div></li><li id="extension-Re_cross" class="def extension anchored"><a href="#extension-Re_cross" class="anchor"></a><code><span>| </span><span><span class="extension">Re_cross</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_cross: String_RegLan -&gt; String_RegLan</code>: Kleen cross.</p><span class="comment-delim">*)</span></div></li><li id="extension-Re_complement" class="def extension anchored"><a href="#extension-Re_complement" class="anchor"></a><code><span>| </span><span><span class="extension">Re_complement</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_complement: String_RegLan -&gt; String_RegLan</code>: language complement.</p><span class="comment-delim">*)</span></div></li><li id="extension-Re_diff" class="def extension anchored"><a href="#extension-Re_diff" class="anchor"></a><code><span>| </span><span><span class="extension">Re_diff</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_diff: String_RegLan -&gt; String_RegLan -&gt; String_RegLan</code>: language difference.</p><span class="comment-delim">*)</span></div></li><li id="extension-Re_option" class="def extension anchored"><a href="#extension-Re_option" class="anchor"></a><code><span>| </span><span><span class="extension">Re_option</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_option: String_RegLan -&gt; String_RegLan</code>: language option <code>Re_option e</code> abbreviates <code>Re_union e (Str_to_re &quot;&quot;)</code>.</p><span class="comment-delim">*)</span></div></li><li id="extension-Re_power" class="def extension anchored"><a href="#extension-Re_power" class="anchor"></a><code><span>| </span><span><span class="extension">Re_power</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_power(n): String_RegLan -&gt; String_RegLan</code>: <code>Re_power(n) e</code> is the nth power of e:</p><ul><li><code>Re_power(0) e</code> is <code>Str_to_re &quot;&quot;</code></li><li><code>Re_power(n+1) e</code> is <code>Re_concat e (Re_power(n) e)</code></li></ul><span class="comment-delim">*)</span></div></li><li id="extension-Re_loop" class="def extension anchored"><a href="#extension-Re_loop" class="anchor"></a><code><span>| </span><span><span class="extension">Re_loop</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_loop(n1,n2): String_RegLan -&gt; String_RegLan</code>: Defined as:</p><ul><li><code>Re_loop(n₁, n₂) e</code> is <code>Re_empty</code> if n₁ &gt; n₂</li><li><code>Re_loop(n₁, n₂) e</code> is <code>Re_power(n₁) e</code> if n₁ = n₂</li><li><code>Re_loop(n₁, n₂) e</code> is <code>Re_union ((Re_power(n₁) e) ... (Re_power(n₂) e))</code> if n₁ &lt; n₂</li></ul><span class="comment-delim">*)</span></div></li></ol></div></div></div></body></html>