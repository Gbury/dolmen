<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Builtin (dolmen.Dolmen_std.Builtin)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">dolmen</a> &#x00BB; <a href="../index.html">Dolmen_std</a> &#x00BB; Builtin</nav><header class="odoc-preamble"><h1>Module <code><span>Dolmen_std.Builtin</span></code></h1><p>This module defines the builtins that are defined by Dolmen.</p><p>Builtins are particularly used in typed expressions see <a href="../Expr/index.html"><code>Dolmen.Std.Expr</code></a>, in order to give more information about constants which have builtin semantics.</p><p>Users are encouraged to match builtins rather than specific symbols when inspecting typed expressions, as this basically allows to match on the semantics of an identifier rather than matching on the syntaxic value of an identifier. For instance, equality can take an arbitrary number of arguments, and thus in order to have well-typed terms, each arity of equality gives rise to a different symbol (because the symbol's type depends on the arity desired), but all these symbols have the <code>Equal</code> builtin.</p><p>In the following we will use pseudo-code to describe the arity and actual type associated to builtins. These will follow ocaml's notation for types with an additional syntax using dots for arbitrary arity. Some examples:</p><ul><li><code>ttype</code> is a type constant</li><li><code>ttype -&gt; ttype</code> is a type constructor (e.g. <code>list</code>)</li><li><code>int</code> is a constant of type <code>int</code></li><li><code>float -&gt; int</code> is a unary function</li><li><code>'a. 'a -&gt; 'a</code> is a polymorphic unary function</li><li><code>'a. 'a -&gt; ... -&gt; Prop.T</code> describes a family of functions that take a type and then an arbitrary number of arguments of that type, and return a proposition (this is for instance the type of equality).</li></ul><p>Additionally, due to some languages having overloaded operators, and in order to not have too verbose names, some of these builtins may have overloaded signtures, such as comparisons on numbers which can operate on integers, rationals, or reals. Note that arbitrary arity operators (well family of operators) can be also be seen as overloaded operators. Overloaded types (particularly for numbers) are written:</p><ul><li><code>{a=(Int|Rational|Real)} a -&gt; a -&gt; Prop.T</code>, where the notable difference with polymorphic functions is that functions of this type does not take a type argument.</li></ul></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#type-definition">Type definition</a></li><li><a href="#base-builtins">Base Builtins</a></li><li><a href="#boolean-builtins">Boolean Builtins</a></li><li><a href="#algebraic-datatype-builtins">Algebraic datatype Builtins</a></li><li><a href="#hol-encoding-builtins">HOL encoding Builtins</a></li><li><a href="#arithmetic-builtins">Arithmetic Builtins</a></li><li><a href="#arrays-builtins">Arrays Builtins</a></li><li><a href="#bitvectors-builtins">Bitvectors Builtins</a></li><li><a href="#floats-builtins">Floats Builtins</a></li><li><a href="#string-and-regexp-builtins">String and Regexp Builtins</a></li></ul></nav></div><div class="odoc-content"><h3 id="type-definition"><a href="#type-definition" class="anchor"></a>Type definition</h3><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span><span> = <span><span class="type-var">'a</span> <a href="../../Dolmen_intf/Builtin/index.html#type-t">Dolmen_intf.Builtin.t</a></span></span><span> = </span><span>..</span><span> <span class="keyword">constraint</span> <span class="type-var">'a</span> = <span>&lt; .. &gt;</span></span></code></div></div><h3 id="base-builtins"><a href="#base-builtins" class="anchor"></a>Base Builtins</h3><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Base"><a href="#extension-decl-Base" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Base" class="def variant extension anchored"><a href="#extension-Base" class="anchor"></a><code><span>| </span><span><span class="extension">Base</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The base builtin; it is the default builtin for identifiers.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Wildcard"><a href="#extension-decl-Wildcard" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Wildcard" class="def variant extension anchored"><a href="#extension-Wildcard" class="anchor"></a><code><span>| </span><span><span class="extension">Wildcard</span> : </span><span>{</span></code><ol><li id="module-Builtin.ty" class="def record field anchored"><a href="#module-Builtin.ty" class="anchor"></a><code><span>ty : <span><span><span class="type-var">'ty</span> option</span> <span class="xref-unresolved">Stdlib</span>.ref</span>;</span></code></li></ol><code><span>}</span><span> <span class="arrow">&#45;&gt;</span> <span><span>&lt; ty : <span class="type-var">'ty</span>.. &gt;</span> <a href="#type-t">t</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Wildcards, currently used internally to represent implicit type variables during type-checking.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Kind"><a href="#extension-decl-Kind" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Kind" class="def variant extension anchored"><a href="#extension-Kind" class="anchor"></a><code><span>| </span><span><span class="extension">Kind</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Used for the type of <code>Type</code>. It is an error to try and access the type of kind.</p><span class="comment-delim">*)</span></div></li><li id="extension-Type" class="def variant extension anchored"><a href="#extension-Type" class="anchor"></a><code><span>| </span><span><span class="extension">Type</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Builtin used to represent the type of types.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Unit"><a href="#extension-decl-Unit" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Unit" class="def variant extension anchored"><a href="#extension-Unit" class="anchor"></a><code><span>| </span><span><span class="extension">Unit</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The unit type, which has only one element (named void).</p><span class="comment-delim">*)</span></div></li><li id="extension-Univ" class="def variant extension anchored"><a href="#extension-Univ" class="anchor"></a><code><span>| </span><span><span class="extension">Univ</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Univ: ttype</code>: a builtin type constant used for languages with a default type for elements (such as tptp's `$i`).</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Equal"><a href="#extension-decl-Equal" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Equal" class="def variant extension anchored"><a href="#extension-Equal" class="anchor"></a><code><span>| </span><span><span class="extension">Equal</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Equal: 'a. 'a -&gt; ... -&gt; Prop.T</code>: equality beetween values.</p><span class="comment-delim">*)</span></div></li><li id="extension-Distinct" class="def variant extension anchored"><a href="#extension-Distinct" class="anchor"></a><code><span>| </span><span><span class="extension">Distinct</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Distinct: 'a. 'a -&gt; ... -&gt; Prop.T</code>: pairwise dis-equality beetween arguments.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Coercion"><a href="#extension-decl-Coercion" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Coercion" class="def variant extension anchored"><a href="#extension-Coercion" class="anchor"></a><code><span>| </span><span><span class="extension">Coercion</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Coercion: 'a 'b. 'a -&gt; 'b</code>: Coercion/cast operator, i.e. allows to cast values of some type to another type. This is a polymorphic operator that takes two type arguments <code>a</code> and <code>b</code>, a value of type <code>a</code>, and returns a value of type <code>b</code>. The interpretation/semantics of this cast can remain up to the user. This operator is currently mainly used to cast numeric types when this transormation is exact (i.e. an integer casted into a rational, which is always possible and exact, or the cast of a rational into an integer, as long as the cast is guarded by a clause verifying the rational is an integer).</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Multi_trigger"><a href="#extension-decl-Multi_trigger" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Multi_trigger" class="def variant extension anchored"><a href="#extension-Multi_trigger" class="anchor"></a><code><span>| </span><span><span class="extension">Multi_trigger</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Multi_trigger: 'a1 ... 'an. 'a1 -&gt; ... -&gt; 'an -&gt; Prop.T</code>: Create a multi trigger: it takes an arbitrarily long list of terms of arbitrary types.</p><span class="comment-delim">*)</span></div></li><li id="extension-Maps_to" class="def variant extension anchored"><a href="#extension-Maps_to" class="anchor"></a><code><span>| </span><span><span class="extension">Maps_to</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Maps_to: 'term_var -&gt; 'term -&gt; Prop.T</code>: Used in semantic triggers for floating point arithmetic. See <code>alt-ergo/src/preludes/fpa-theory-2017-01-04-16h00.ae</code>.</p><p><code>warning:</code> It is an Alt-Ergo semantic trigger that should only be allowed inside theories.</p><span class="comment-delim">*)</span></div></li><li id="extension-Semantic_trigger" class="def variant extension anchored"><a href="#extension-Semantic_trigger" class="anchor"></a><code><span>| </span><span><span class="extension">Semantic_trigger</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Semantic_trigger: Prop.T -&gt; Prop.T</code>: Denote that its argument is a semantic trigger (used only by Alt-ergo currently).</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Pi"><a href="#extension-decl-Pi" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Pi" class="def variant extension anchored"><a href="#extension-Pi" class="anchor"></a><code><span>| </span><span><span class="extension">Pi</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Pi: 'a. ('a -&gt; Prop.T) -&gt; Prop.T</code>: higher-order encoding of universal quantification.</p><span class="comment-delim">*)</span></div></li><li id="extension-Sigma" class="def variant extension anchored"><a href="#extension-Sigma" class="anchor"></a><code><span>| </span><span><span class="extension">Sigma</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Sigma: 'a. ('a -&gt; Prop.T) -&gt; Prop.T</code>: higher-order encoding of existencial quantification.</p><span class="comment-delim">*)</span></div></li></ol></div></div><h3 id="boolean-builtins"><a href="#boolean-builtins" class="anchor"></a>Boolean Builtins</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Prop"><a href="#module-Prop" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Prop/index.html">Prop</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Prop"><a href="#extension-decl-Prop" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Prop" class="def variant extension anchored"><a href="#extension-Prop" class="anchor"></a><code><span>| </span><span><span class="extension">Prop</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="Prop/index.html#type-t">Prop.t</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean builtins.</p><span class="comment-delim">*)</span></div></li></ol></div></div><h3 id="algebraic-datatype-builtins"><a href="#algebraic-datatype-builtins" class="anchor"></a>Algebraic datatype Builtins</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Adt"><a href="#module-Adt" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Adt/index.html">Adt</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Adt"><a href="#extension-decl-Adt" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Adt" class="def variant extension anchored"><a href="#extension-Adt" class="anchor"></a><code><span>| </span><span><span class="extension">Adt</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="Adt/index.html#type-t">Adt.t</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Alegbraic datatype builtins.</p><span class="comment-delim">*)</span></div></li></ol></div></div><h3 id="hol-encoding-builtins"><a href="#hol-encoding-builtins" class="anchor"></a>HOL encoding Builtins</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Map"><a href="#module-Map" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Map/index.html">Map</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Map"><a href="#extension-decl-Map" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Map" class="def variant extension anchored"><a href="#extension-Map" class="anchor"></a><code><span>| </span><span><span class="extension">Map</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="Map/index.html#type-t">Map.t</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Map/Higher-order encoding builtins.</p><span class="comment-delim">*)</span></div></li></ol></div></div><h3 id="arithmetic-builtins"><a href="#arithmetic-builtins" class="anchor"></a>Arithmetic Builtins</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Arith"><a href="#module-Arith" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Arith/index.html">Arith</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Arith"><a href="#extension-decl-Arith" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Arith" class="def variant extension anchored"><a href="#extension-Arith" class="anchor"></a><code><span>| </span><span><span class="extension">Arith</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="Arith/index.html#type-t">Arith.t</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Arithmetic builtins.</p><span class="comment-delim">*)</span></div></li></ol></div></div><h3 id="arrays-builtins"><a href="#arrays-builtins" class="anchor"></a>Arrays Builtins</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Array"><a href="#module-Array" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Array/index.html">Array</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Array"><a href="#extension-decl-Array" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Array" class="def variant extension anchored"><a href="#extension-Array" class="anchor"></a><code><span>| </span><span><span class="extension">Array</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="Array/index.html#type-t">Array.t</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Array builtins.</p><span class="comment-delim">*)</span></div></li></ol></div></div><h3 id="bitvectors-builtins"><a href="#bitvectors-builtins" class="anchor"></a>Bitvectors Builtins</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Bitv"><a href="#module-Bitv" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Bitv/index.html">Bitv</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Bitv"><a href="#extension-decl-Bitv" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Bitv" class="def variant extension anchored"><a href="#extension-Bitv" class="anchor"></a><code><span>| </span><span><span class="extension">Bitv</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="Bitv/index.html#type-t">Bitv.t</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bitvectors builtins</p><span class="comment-delim">*)</span></div></li></ol></div></div><h3 id="floats-builtins"><a href="#floats-builtins" class="anchor"></a>Floats Builtins</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Float"><a href="#module-Float" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Float/index.html">Float</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Float"><a href="#extension-decl-Float" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Float" class="def variant extension anchored"><a href="#extension-Float" class="anchor"></a><code><span>| </span><span><span class="extension">Float</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="Float/index.html#type-t">Float.t</a></span></span></code></li></ol></div></div><h3 id="string-and-regexp-builtins"><a href="#string-and-regexp-builtins" class="anchor"></a>String and Regexp Builtins</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Str"><a href="#module-Str" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Str/index.html">Str</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Str"><a href="#extension-decl-Str" class="anchor"></a><code><span><span class="keyword">type</span> <a href="#type-t">t</a> += </span></code><ol><li id="extension-Str" class="def variant extension anchored"><a href="#extension-Str" class="anchor"></a><code><span>| </span><span><span class="extension">Str</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="Str/index.html#type-t">Str.t</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>String builtins</p><span class="comment-delim">*)</span></div></li><li id="extension-Regexp" class="def variant extension anchored"><a href="#extension-Regexp" class="anchor"></a><code><span>| </span><span><span class="extension">Regexp</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="Str/RegLan/index.html#type-t">Str.RegLan.t</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>String Regular language builtins, aka regexps.</p><span class="comment-delim">*)</span></div></li></ol></div></div></div></body></html>
