<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bitv (dolmen.Dolmen_std.Builtin.Bitv)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">Index</a> &#x00BB; <a href="../../../index.html">dolmen</a> &#x00BB; <a href="../../index.html">Dolmen_std</a> &#x00BB; <a href="../index.html">Builtin</a> &#x00BB; Bitv</nav><header class="odoc-preamble"><h1>Module <code><span>Builtin.Bitv</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>_ t</span></span><span> = </span></code><ol><li id="type-t.T" class="def variant constructor anchored"><a href="#type-t.T" class="anchor"></a><code><span>| </span><span><span class="constructor">T</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Bitv.T{n}: ttype</code>: type constructor for bitvectors of length <code>n</code>. Ensures that <code>n &gt; 0</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Binary_lit" class="def variant constructor anchored"><a href="#type-t.Binary_lit" class="anchor"></a><code><span>| </span><span><span class="constructor">Binary_lit</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Lit s: Bitv.T</code>: bitvector litteral. The string <code>s</code> should be a binary representation of bitvectors using characters <code>'0'</code>, and <code>'1'</code> (lsb last)</p><span class="comment-delim">*)</span></div></li><li id="type-t.To_int" class="def variant constructor anchored"><a href="#type-t.To_int" class="anchor"></a><code><span>| </span><span><span class="constructor">To_int</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li><li id="type-t.signed" class="def record field anchored"><a href="#type-t.signed" class="anchor"></a><code><span>signed : bool;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>To_int{n; signed; }: Bitv.T{n} -&gt; Int</code>: conversion from bitvectors to signed integers.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Of_int" class="def variant constructor anchored"><a href="#type-t.Of_int" class="anchor"></a><code><span>| </span><span><span class="constructor">Of_int</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Of_int{n}: Int -&gt; Bitv.T{n}</code>: conversion fromm (signed) integers to bitvectors.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Concat" class="def variant constructor anchored"><a href="#type-t.Concat" class="anchor"></a><code><span>| </span><span><span class="constructor">Concat</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li><li id="type-t.m" class="def record field anchored"><a href="#type-t.m" class="anchor"></a><code><span>m : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Concat{n;m}: Bitv.T{n} -&gt; Bitv.T{m} -&gt; Bitv.T{n+m}</code>: concatenation operator on bitvectors.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Extract" class="def variant constructor anchored"><a href="#type-t.Extract" class="anchor"></a><code><span>| </span><span><span class="constructor">Extract</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li><li id="type-t.i" class="def record field anchored"><a href="#type-t.i" class="anchor"></a><code><span>i : int;</span></code></li><li id="type-t.j" class="def record field anchored"><a href="#type-t.j" class="anchor"></a><code><span>j : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Extract{n; i; j}: Bitv.T{n} -&gt; Bitv.T{i - j + 1}</code>: bitvector extraction, from index <code>j</code> up to <code>i</code> (both included). Ensures that <code>0 &lt;= j &lt;= i &lt; n</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Repeat" class="def variant constructor anchored"><a href="#type-t.Repeat" class="anchor"></a><code><span>| </span><span><span class="constructor">Repeat</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li><li id="type-t.k" class="def record field anchored"><a href="#type-t.k" class="anchor"></a><code><span>k : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Repeat{n;k}: Bitv.T{n} -&gt; Bitv.T{n*k}</code>: bitvector repeatition.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Zero_extend" class="def variant constructor anchored"><a href="#type-t.Zero_extend" class="anchor"></a><code><span>| </span><span><span class="constructor">Zero_extend</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li><li id="type-t.k" class="def record field anchored"><a href="#type-t.k" class="anchor"></a><code><span>k : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Zero_extend{n;k}: Bitv.T{n} -&gt; Bitv.T{n + k}</code>: zero extension for bitvectors (produces a representation of the same unsigned integer).</p><span class="comment-delim">*)</span></div></li><li id="type-t.Sign_extend" class="def variant constructor anchored"><a href="#type-t.Sign_extend" class="anchor"></a><code><span>| </span><span><span class="constructor">Sign_extend</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li><li id="type-t.k" class="def record field anchored"><a href="#type-t.k" class="anchor"></a><code><span>k : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Sign_extend{n;k}: Bitv.T{n} -&gt; Bitv.T{n + k}</code>: sign extension for bitvectors ((produces a representation of the same signed integer).</p><span class="comment-delim">*)</span></div></li><li id="type-t.Rotate_right" class="def variant constructor anchored"><a href="#type-t.Rotate_right" class="anchor"></a><code><span>| </span><span><span class="constructor">Rotate_right</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li><li id="type-t.i" class="def record field anchored"><a href="#type-t.i" class="anchor"></a><code><span>i : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Rotate_right{n;i}: Bitv.T{n} -&gt; Bitv.T{n}</code>: logical rotate right for bitvectors by <code>i</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Rotate_left" class="def variant constructor anchored"><a href="#type-t.Rotate_left" class="anchor"></a><code><span>| </span><span><span class="constructor">Rotate_left</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li><li id="type-t.i" class="def record field anchored"><a href="#type-t.i" class="anchor"></a><code><span>i : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Rotate_left{n;i}: Bitv.T{n} -&gt; Bitv.T{n}</code>: logical rotate left for bitvectors by <code>i</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Not" class="def variant constructor anchored"><a href="#type-t.Not" class="anchor"></a><code><span>| </span><span><span class="constructor">Not</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Not{n}: Bitv.T{n} -&gt; Bitv.T{n}</code>: bitwise negation for bitvectors.</p><span class="comment-delim">*)</span></div></li><li id="type-t.And" class="def variant constructor anchored"><a href="#type-t.And" class="anchor"></a><code><span>| </span><span><span class="constructor">And</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>And{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Bitv.T{n}</code>: bitwise conjunction for bitvectors.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Or" class="def variant constructor anchored"><a href="#type-t.Or" class="anchor"></a><code><span>| </span><span><span class="constructor">Or</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Or{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Bitv.T{n}</code>: bitwise disjunction for bitvectors.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Nand" class="def variant constructor anchored"><a href="#type-t.Nand" class="anchor"></a><code><span>| </span><span><span class="constructor">Nand</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Nand{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Bitv.T{n}</code>: bitwise negated conjunction for bitvectors. <code>Nand s t</code> abbreviates <code>Not (And s t))</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Nor" class="def variant constructor anchored"><a href="#type-t.Nor" class="anchor"></a><code><span>| </span><span><span class="constructor">Nor</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Nor{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Bitv.T{n}</code>: bitwise negated disjunction for bitvectors. <code>Nor s t</code> abbreviates <code>Not (Or s t))</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Xor" class="def variant constructor anchored"><a href="#type-t.Xor" class="anchor"></a><code><span>| </span><span><span class="constructor">Xor</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Xor{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Bitv.T{n}</code>: bitwise exclusive disjunction for bitvectors. <code>Xor s t</code> abbreviates <code>Or (And s (Not t)) (And (Not s) t) </code>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Xnor" class="def variant constructor anchored"><a href="#type-t.Xnor" class="anchor"></a><code><span>| </span><span><span class="constructor">Xnor</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Xnor{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Bitv.T{n}</code>: bitwise negated exclusive disjunction for bitvectors. <code>Xnor s t</code> abbreviates <code>Or (And s t) (And (Not s) (Not t))</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Comp" class="def variant constructor anchored"><a href="#type-t.Comp" class="anchor"></a><code><span>| </span><span><span class="constructor">Comp</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Comp{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Bitv.T{1}</code>: Returns the constant bitvector <code>&quot;1&quot;</code> is all bits are equal, and the bitvector <code>&quot;0&quot;</code> if not.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Neg" class="def variant constructor anchored"><a href="#type-t.Neg" class="anchor"></a><code><span>| </span><span><span class="constructor">Neg</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Neg{n}: Bitv.T{n} -&gt; Bitv.T{n}</code>: 2's complement unary minus.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Add" class="def variant constructor anchored"><a href="#type-t.Add" class="anchor"></a><code><span>| </span><span><span class="constructor">Add</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Add{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Bitv.T{n}</code>: addition modulo 2^n.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Sub" class="def variant constructor anchored"><a href="#type-t.Sub" class="anchor"></a><code><span>| </span><span><span class="constructor">Sub</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Sub{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Bitv.T{n}</code>: 2's complement subtraction modulo 2^n.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Mul" class="def variant constructor anchored"><a href="#type-t.Mul" class="anchor"></a><code><span>| </span><span><span class="constructor">Mul</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Mul{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Bitv.T{n}</code>: multiplication modulo 2^n.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Udiv" class="def variant constructor anchored"><a href="#type-t.Udiv" class="anchor"></a><code><span>| </span><span><span class="constructor">Udiv</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Udiv{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Bitv.T{n}</code>: unsigned division, truncating towards 0.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Urem" class="def variant constructor anchored"><a href="#type-t.Urem" class="anchor"></a><code><span>| </span><span><span class="constructor">Urem</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Urem{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Bitv.T{n}</code>: unsigned remainder from truncating division.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Sdiv" class="def variant constructor anchored"><a href="#type-t.Sdiv" class="anchor"></a><code><span>| </span><span><span class="constructor">Sdiv</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Sdiv{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Bitv.T{n}</code>: 2's complement signed division.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Srem" class="def variant constructor anchored"><a href="#type-t.Srem" class="anchor"></a><code><span>| </span><span><span class="constructor">Srem</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Srem{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Bitv.T{n}</code>: 2's complement signed remainder (sign follows dividend).</p><span class="comment-delim">*)</span></div></li><li id="type-t.Smod" class="def variant constructor anchored"><a href="#type-t.Smod" class="anchor"></a><code><span>| </span><span><span class="constructor">Smod</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Smod{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Bitv.T{n}</code>: 2's complement signed remainder (sign follows divisor).</p><span class="comment-delim">*)</span></div></li><li id="type-t.Shl" class="def variant constructor anchored"><a href="#type-t.Shl" class="anchor"></a><code><span>| </span><span><span class="constructor">Shl</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Shl{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Bitv.T{n}</code>: shift left (equivalent to multiplication by 2^x where x is the value of the second argument).</p><span class="comment-delim">*)</span></div></li><li id="type-t.Lshr" class="def variant constructor anchored"><a href="#type-t.Lshr" class="anchor"></a><code><span>| </span><span><span class="constructor">Lshr</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Lshr{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Bitv.T{n}</code>: logical shift right (equivalent to unsigned division by 2^x, where x is the value of the second argument).</p><span class="comment-delim">*)</span></div></li><li id="type-t.Ashr" class="def variant constructor anchored"><a href="#type-t.Ashr" class="anchor"></a><code><span>| </span><span><span class="constructor">Ashr</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Ashr{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Bitv.T{n}</code>: Arithmetic shift right, like logical shift right except that the most significant bits of the result always copy the most significant bit of the first argument.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Ult" class="def variant constructor anchored"><a href="#type-t.Ult" class="anchor"></a><code><span>| </span><span><span class="constructor">Ult</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Ult{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Prop.T</code>: binary predicate for unsigned less-than.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Ule" class="def variant constructor anchored"><a href="#type-t.Ule" class="anchor"></a><code><span>| </span><span><span class="constructor">Ule</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Ule{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Prop.T</code>: binary predicate for unsigned less than or equal.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Ugt" class="def variant constructor anchored"><a href="#type-t.Ugt" class="anchor"></a><code><span>| </span><span><span class="constructor">Ugt</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Ugt{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Prop.T</code>: binary predicate for unsigned greater-than.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Uge" class="def variant constructor anchored"><a href="#type-t.Uge" class="anchor"></a><code><span>| </span><span><span class="constructor">Uge</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Uge{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Prop.T</code>: binary predicate for unsigned greater than or equal.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Slt" class="def variant constructor anchored"><a href="#type-t.Slt" class="anchor"></a><code><span>| </span><span><span class="constructor">Slt</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Slt{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Prop.T</code>: binary predicate for signed less-than.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Sle" class="def variant constructor anchored"><a href="#type-t.Sle" class="anchor"></a><code><span>| </span><span><span class="constructor">Sle</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Sle{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Prop.T</code>: binary predicate for signed less than or equal.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Sgt" class="def variant constructor anchored"><a href="#type-t.Sgt" class="anchor"></a><code><span>| </span><span><span class="constructor">Sgt</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Sgt{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Prop.T</code>: binary predicate for signed greater-than.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Sge" class="def variant constructor anchored"><a href="#type-t.Sge" class="anchor"></a><code><span>| </span><span><span class="constructor">Sge</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Sge{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Prop.T</code>: binary predicate for signed greater than or equal.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Overflow_neg" class="def variant constructor anchored"><a href="#type-t.Overflow_neg" class="anchor"></a><code><span>| </span><span><span class="constructor">Overflow_neg</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Overflow_neg{n} : Bitv.T{n} -&gt; Prop.T</code>: unary overflow predicate for signed unary minus (i.e. returns <code>true</code> if the negation would overflow)</p><span class="comment-delim">*)</span></div></li><li id="type-t.Overflow_add" class="def variant constructor anchored"><a href="#type-t.Overflow_add" class="anchor"></a><code><span>| </span><span><span class="constructor">Overflow_add</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li><li id="type-t.signed" class="def record field anchored"><a href="#type-t.signed" class="anchor"></a><code><span>signed : bool;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Overflow_add{n;signed} : Bitv.T{n} -&gt; Bitv.T{n} -&gt; Prop.T</code>: binary overflow predicate for signed/unsigned addition (i.e. returns <code>true</code> if the operation would overflow)</p><span class="comment-delim">*)</span></div></li><li id="type-t.Overflow_sub" class="def variant constructor anchored"><a href="#type-t.Overflow_sub" class="anchor"></a><code><span>| </span><span><span class="constructor">Overflow_sub</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li><li id="type-t.signed" class="def record field anchored"><a href="#type-t.signed" class="anchor"></a><code><span>signed : bool;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Overflow_sub{n;signed}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Prop.T binary overflow predicate for signed/unsigned subtraction (i.e. returns [true] if the operation would overflow) </code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Overflow_mul" class="def variant constructor anchored"><a href="#type-t.Overflow_mul" class="anchor"></a><code><span>| </span><span><span class="constructor">Overflow_mul</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li><li id="type-t.signed" class="def record field anchored"><a href="#type-t.signed" class="anchor"></a><code><span>signed : bool;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Overflow_mul{n;signed}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Prop.T binary overflow predicate for signed/unsigned multiplication (i.e. returns [true] if the operation would overflow) </code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Overflow_div" class="def variant constructor anchored"><a href="#type-t.Overflow_div" class="anchor"></a><code><span>| </span><span><span class="constructor">Overflow_div</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-t.n" class="def record field anchored"><a href="#type-t.n" class="anchor"></a><code><span>n : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Overflow_div{n}: Bitv.T{n} -&gt; Bitv.T{n} -&gt; Prop.T binary overflow predicate for signed division (i.e. returns [true] if the operation would overflow) </code></p><span class="comment-delim">*)</span></div></li></ol></div></div></div></body></html>
