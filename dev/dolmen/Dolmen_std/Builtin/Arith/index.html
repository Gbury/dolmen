<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Arith (dolmen.Dolmen_std.Builtin.Arith)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">Index</a> &#x00BB; <a href="../../../index.html">dolmen</a> &#x00BB; <a href="../../index.html">Dolmen_std</a> &#x00BB; <a href="../index.html">Builtin</a> &#x00BB; Arith</nav><header class="odoc-preamble"><h1>Module <code><span>Builtin.Arith</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>_ t</span></span><span> = </span></code><ol><li id="type-t.Int" class="def variant constructor anchored"><a href="#type-t.Int" class="anchor"></a><code><span>| </span><span><span class="constructor">Int</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Int: ttype</code> the type for signed integers of arbitrary precision.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Integer" class="def variant constructor anchored"><a href="#type-t.Integer" class="anchor"></a><code><span>| </span><span><span class="constructor">Integer</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Integer s: Int</code>: integer literal. The string <code>s</code> should be the decimal representation of an integer with arbitrary precision (hence the use of strings rather than the limited precision <code>int</code>).</p><span class="comment-delim">*)</span></div></li><li id="type-t.Rat" class="def variant constructor anchored"><a href="#type-t.Rat" class="anchor"></a><code><span>| </span><span><span class="constructor">Rat</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Rat: ttype</code> the type for signed rationals.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Rational" class="def variant constructor anchored"><a href="#type-t.Rational" class="anchor"></a><code><span>| </span><span><span class="constructor">Rational</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Rational s: Rational</code>: rational literal. The string <code>s</code> should be the decimal representation of a rational (see the various languages spec for more information).</p><span class="comment-delim">*)</span></div></li><li id="type-t.Real" class="def variant constructor anchored"><a href="#type-t.Real" class="anchor"></a><code><span>| </span><span><span class="constructor">Real</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Real: ttype</code> the type for signed reals.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Decimal" class="def variant constructor anchored"><a href="#type-t.Decimal" class="anchor"></a><code><span>| </span><span><span class="constructor">Decimal</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Decimal s: Real</code>: real literals. The string <code>s</code> should be a floating point representation of a real. Not however that reals here means the mathematical abstract notion of real numbers, including irrational, non-algebric numbers, and is thus not restricted to floating point numbers, although these are the only literals supported.</p><p>Note that, in spite of the name, the literals may not be expressed in decimal notation. For instance, <code>Decimal &quot;0x1.0p1&quot;</code> is a valid representation for the real number <code>2</code>.</p><p>Real literals can be parsed using ZArith's <code>Q.of_string</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Lt" class="def variant constructor anchored"><a href="#type-t.Lt" class="anchor"></a><code><span>| </span><span><span class="constructor">Lt</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Lt: {a=(Int|Rational|Real)} a -&gt; a -&gt; Prop.T</code>: strict comparison (less than) on numbers (whether integers, rationals, or reals).</p><span class="comment-delim">*)</span></div></li><li id="type-t.Leq" class="def variant constructor anchored"><a href="#type-t.Leq" class="anchor"></a><code><span>| </span><span><span class="constructor">Leq</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Leq:{a=(Int|Rational|Real)} a -&gt; a -&gt; Prop.T</code>: large comparison (less or equal than) on numbers (whether integers, rationals, or reals).</p><span class="comment-delim">*)</span></div></li><li id="type-t.Gt" class="def variant constructor anchored"><a href="#type-t.Gt" class="anchor"></a><code><span>| </span><span><span class="constructor">Gt</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Gt:{a=(Int|Rational|Real)} a -&gt; a -&gt; Prop.T</code>: strict comparison (greater than) on numbers (whether integers, rationals, or reals).</p><span class="comment-delim">*)</span></div></li><li id="type-t.Geq" class="def variant constructor anchored"><a href="#type-t.Geq" class="anchor"></a><code><span>| </span><span><span class="constructor">Geq</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Geq:{a=(Int|Rational|Real)} a -&gt; a -&gt; Prop.T</code>: large comparison (greater or equal than) on numbers (whether integers, rationals, or reals).</p><span class="comment-delim">*)</span></div></li><li id="type-t.Minus" class="def variant constructor anchored"><a href="#type-t.Minus" class="anchor"></a><code><span>| </span><span><span class="constructor">Minus</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Minus:{a=(Int|Rational|Real)} a -&gt; a</code>: arithmetic unary negation/minus on numbers (whether integers, rationals, or reals).</p><span class="comment-delim">*)</span></div></li><li id="type-t.Add" class="def variant constructor anchored"><a href="#type-t.Add" class="anchor"></a><code><span>| </span><span><span class="constructor">Add</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Add:{a=(Int|Rational|Real)} a -&gt; a -&gt; a</code>: arithmetic addition on numbers (whether integers, rationals, or reals).</p><span class="comment-delim">*)</span></div></li><li id="type-t.Sub" class="def variant constructor anchored"><a href="#type-t.Sub" class="anchor"></a><code><span>| </span><span><span class="constructor">Sub</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Sub:{a=(Int|Rational|Real)} a -&gt; a -&gt; a</code>: arithmetic substraction on numbers (whether integers, rationals, or reals).</p><span class="comment-delim">*)</span></div></li><li id="type-t.Mul" class="def variant constructor anchored"><a href="#type-t.Mul" class="anchor"></a><code><span>| </span><span><span class="constructor">Mul</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Mul:{a=(Int|Rational|Real)} a -&gt; a -&gt; a</code>: arithmetic multiplication on numbers (whether integers, rationals, or reals).</p><span class="comment-delim">*)</span></div></li><li id="type-t.Pow" class="def variant constructor anchored"><a href="#type-t.Pow" class="anchor"></a><code><span>| </span><span><span class="constructor">Pow</span> <span class="keyword">of</span> <span>[ `Int <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Pow:{a=(Int|Real)} a -&gt; a -&gt; a</code>: arithmetic exponentiation on numbers (whether integers or reals).</p><span class="comment-delim">*)</span></div></li><li id="type-t.Div" class="def variant constructor anchored"><a href="#type-t.Div" class="anchor"></a><code><span>| </span><span><span class="constructor">Div</span> <span class="keyword">of</span> <span>[ `Rat <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Div:{a=(Rational|Real)} a -&gt; a -&gt; a</code>: arithmetic exact division on numbers (rationals, or reals, but **not** integers).</p><span class="comment-delim">*)</span></div></li><li id="type-t.Div_e" class="def variant constructor anchored"><a href="#type-t.Div_e" class="anchor"></a><code><span>| </span><span><span class="constructor">Div_e</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Div_e:{a=(Int|Rational|Real)} a -&gt; a -&gt; a</code>: arithmetic integer euclidian quotient (whether integers, rationals, or reals). If D is positive then <code>Div_e (N,D)</code> is the floor (in the type of N and D) of the real division <code>N/D</code>, and if D is negative then <code>Div_e (N,D)</code> is the ceiling of <code>N/D</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Modulo_e" class="def variant constructor anchored"><a href="#type-t.Modulo_e" class="anchor"></a><code><span>| </span><span><span class="constructor">Modulo_e</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Modulo_e:{a=(Int|Rational|Real)} a -&gt; a -&gt; a</code>: arithmetic integer euclidian remainder (whether integers, rationals, or reals). It is defined by the following equation: <code>Div_e (N, D) * D + Modulo(N, D) = N</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Div_t" class="def variant constructor anchored"><a href="#type-t.Div_t" class="anchor"></a><code><span>| </span><span><span class="constructor">Div_t</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Div_t:{a=(Int|Rational|Real)} a -&gt; a -&gt; a</code>: arithmetic integer truncated quotient (whether integers, rationals, or reals). <code>Div_t (N,D)</code> is the truncation of the real division <code>N/D</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Modulo_t" class="def variant constructor anchored"><a href="#type-t.Modulo_t" class="anchor"></a><code><span>| </span><span><span class="constructor">Modulo_t</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Modulo_t:{a=(Int|Rational|Real)} a -&gt; a -&gt; a</code>: arithmetic integer truncated remainder (whether integers, rationals, or reals). It is defined by the following equation: <code>Div_t (N, D) * D + Modulo_t(N, D) = N</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Div_f" class="def variant constructor anchored"><a href="#type-t.Div_f" class="anchor"></a><code><span>| </span><span><span class="constructor">Div_f</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Div_f:{a=(Int|Rational|Real)} a -&gt; a -&gt; a</code>: arithmetic integer floor quotient (whether integers, rationals, or reals). <code>Div_t (N,D)</code> is the floor of the real division <code>N/D</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Modulo_f" class="def variant constructor anchored"><a href="#type-t.Modulo_f" class="anchor"></a><code><span>| </span><span><span class="constructor">Modulo_f</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Modulo_f:{a=(Int|Rational|Real)} a -&gt; a -&gt; a</code>: arithmetic integer floor remainder (whether integers, rationals, or reals). It is defined by the following equation: <code>Div_f (N, D) * D + Modulo_f(N, D) = N</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Abs" class="def variant constructor anchored"><a href="#type-t.Abs" class="anchor"></a><code><span>| </span><span><span class="constructor">Abs</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Abs: Int -&gt; Int</code>: absolute value on integers.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Divisible" class="def variant constructor anchored"><a href="#type-t.Divisible" class="anchor"></a><code><span>| </span><span><span class="constructor">Divisible</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Divisible: Int -&gt; Int -&gt; Prop.T</code>: divisibility predicate on integers. Smtlib restricts applications of this predicate to have a litteral integer for the divisor/second argument.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Is_int" class="def variant constructor anchored"><a href="#type-t.Is_int" class="anchor"></a><code><span>| </span><span><span class="constructor">Is_int</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Is_int:{a=(Int|Rational|Real)} a -&gt; Prop.T</code>: integer predicate for numbers: is the given number an integer.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Is_rat" class="def variant constructor anchored"><a href="#type-t.Is_rat" class="anchor"></a><code><span>| </span><span><span class="constructor">Is_rat</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Is_rat:{a=(Int|Rational|Real)} a -&gt; Prop.T</code>: rational predicate for numbers: is the given number an rational.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Floor" class="def variant constructor anchored"><a href="#type-t.Floor" class="anchor"></a><code><span>| </span><span><span class="constructor">Floor</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Floor:{a=(Int|Rational|Real)} a -&gt; a</code>: floor function on numbers, defined in tptp as the largest integer not greater than the argument.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Floor_to_int" class="def variant constructor anchored"><a href="#type-t.Floor_to_int" class="anchor"></a><code><span>| </span><span><span class="constructor">Floor_to_int</span> <span class="keyword">of</span> <span>[ `Rat <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Floor_to_int:{a=(Rational|Real)} a -&gt; Int</code>: floor and conversion to integers in a single function. Should return the greatest integer <code>i</code> such that the rational or real intepretation of <code>i</code> is less than, or equal to, the argument.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Ceiling" class="def variant constructor anchored"><a href="#type-t.Ceiling" class="anchor"></a><code><span>| </span><span><span class="constructor">Ceiling</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Ceiling:{a=(Int|Rational|Real)} a -&gt; a</code>: ceiling function on numbers, defined in tptp as the smallest integer not less than the argument.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Truncate" class="def variant constructor anchored"><a href="#type-t.Truncate" class="anchor"></a><code><span>| </span><span><span class="constructor">Truncate</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Truncate:{a=(Int|Rational|Real)} a -&gt; a</code>: ceiling function on numbers, defined in tptp as the nearest integer value with magnitude not greater than the absolute value of the argument.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Round" class="def variant constructor anchored"><a href="#type-t.Round" class="anchor"></a><code><span>| </span><span><span class="constructor">Round</span> <span class="keyword">of</span> <span>[ `Int <span>| `Rat</span> <span>| `Real</span> ]</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Round:{a=(Int|Rational|Real)} a -&gt; a</code>: rounding function on numbers, defined in tptp as the nearest intger to the argument; when the argument is halfway between two integers, the nearest even integer to the argument.</p><span class="comment-delim">*)</span></div></li></ol></div></div></div></body></html>
