<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>RegLan (dolmen.Dolmen_std.Builtin.Str.RegLan)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../../../../index.html">Index</a> &#x00BB; <a href="../../../../index.html">dolmen</a> &#x00BB; <a href="../../../index.html">Dolmen_std</a> &#x00BB; <a href="../../index.html">Builtin</a> &#x00BB; <a href="../index.html">Str</a> &#x00BB; RegLan</nav><header class="odoc-preamble"><h1>Module <code><span>Str.RegLan</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>_ t</span></span><span> = </span></code><ol><li id="type-t.T" class="def variant constructor anchored"><a href="#type-t.T" class="anchor"></a><code><span>| </span><span><span class="constructor">T</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>String_RegLan: ttype</code>: type constructor for Regular languages over strings.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Empty" class="def variant constructor anchored"><a href="#type-t.Empty" class="anchor"></a><code><span>| </span><span><span class="constructor">Empty</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_empty: String_RegLan</code>: the empty language.</p><span class="comment-delim">*)</span></div></li><li id="type-t.All" class="def variant constructor anchored"><a href="#type-t.All" class="anchor"></a><code><span>| </span><span><span class="constructor">All</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_all: String_RegLan</code>: the language of all strings.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Allchar" class="def variant constructor anchored"><a href="#type-t.Allchar" class="anchor"></a><code><span>| </span><span><span class="constructor">Allchar</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_allchar: String_RegLan</code>: the language of all singleton strings.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Of_string" class="def variant constructor anchored"><a href="#type-t.Of_string" class="anchor"></a><code><span>| </span><span><span class="constructor">Of_string</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_of_string: String -&gt; String_RegLan</code>: the singleton language with a single string.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Range" class="def variant constructor anchored"><a href="#type-t.Range" class="anchor"></a><code><span>| </span><span><span class="constructor">Range</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_range: String -&gt; String -&gt; String_RegLan</code>: Language range <code>Re_range s1 s2</code> is the set of all *singleton* strings <code>s</code> such that <code>Str_lexicographic_large s1 s s2</code> provided <code>s1</code> and <code>s1</code> are singleton. Otherwise, it is the empty language.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Concat" class="def variant constructor anchored"><a href="#type-t.Concat" class="anchor"></a><code><span>| </span><span><span class="constructor">Concat</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_concat: String_RegLan -&gt; String_RegLan -&gt; String_RegLan</code>: language concatenation.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Union" class="def variant constructor anchored"><a href="#type-t.Union" class="anchor"></a><code><span>| </span><span><span class="constructor">Union</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_union: String_RegLan -&gt; String_RegLan -&gt; String_RegLan</code>: language union.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Inter" class="def variant constructor anchored"><a href="#type-t.Inter" class="anchor"></a><code><span>| </span><span><span class="constructor">Inter</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_inter: String_RegLan -&gt; String_RegLan -&gt; String_RegLan</code>: language intersection.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Star" class="def variant constructor anchored"><a href="#type-t.Star" class="anchor"></a><code><span>| </span><span><span class="constructor">Star</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_star: String_RegLan -&gt; String_RegLan</code>: Kleen star.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Cross" class="def variant constructor anchored"><a href="#type-t.Cross" class="anchor"></a><code><span>| </span><span><span class="constructor">Cross</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_cross: String_RegLan -&gt; String_RegLan</code>: Kleen cross.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Complement" class="def variant constructor anchored"><a href="#type-t.Complement" class="anchor"></a><code><span>| </span><span><span class="constructor">Complement</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_complement: String_RegLan -&gt; String_RegLan</code>: language complement.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Diff" class="def variant constructor anchored"><a href="#type-t.Diff" class="anchor"></a><code><span>| </span><span><span class="constructor">Diff</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_diff: String_RegLan -&gt; String_RegLan -&gt; String_RegLan</code>: language difference.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Option" class="def variant constructor anchored"><a href="#type-t.Option" class="anchor"></a><code><span>| </span><span><span class="constructor">Option</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_option: String_RegLan -&gt; String_RegLan</code>: language option <code>Re_option e</code> abbreviates <code>Re_union e (Str_to_re &quot;&quot;)</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Power" class="def variant constructor anchored"><a href="#type-t.Power" class="anchor"></a><code><span>| </span><span><span class="constructor">Power</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_power(n): String_RegLan -&gt; String_RegLan</code>: <code>Re_power(n) e</code> is the nth power of e:</p><ul><li><code>Re_power(0) e</code> is <code>Str_to_re &quot;&quot;</code></li><li><code>Re_power(n+1) e</code> is <code>Re_concat e (Re_power(n) e)</code></li></ul><span class="comment-delim">*)</span></div></li><li id="type-t.Loop" class="def variant constructor anchored"><a href="#type-t.Loop" class="anchor"></a><code><span>| </span><span><span class="constructor">Loop</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Re_loop(n1,n2): String_RegLan -&gt; String_RegLan</code>: Defined as:</p><ul><li><code>Re_loop(n₁, n₂) e</code> is <code>Re_empty</code> if n₁ &gt; n₂</li><li><code>Re_loop(n₁, n₂) e</code> is <code>Re_power(n₁) e</code> if n₁ = n₂</li><li><code>Re_loop(n₁, n₂) e</code> is <code>Re_union ((Re_power(n₁) e) ... (Re_power(n₂) e))</code> if n₁ &lt; n₂</li></ul><span class="comment-delim">*)</span></div></li></ol></div></div></div></body></html>
