<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Term (dolmen.Dolmen_std.Term)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">dolmen</a> &#x00BB; <a href="../index.html">Dolmen_std</a> &#x00BB; Term</nav><header class="odoc-preamble"><h1>Module <code><span>Dolmen_std.Term</span></code></h1><p>Standard implementation of terms</p></header><nav class="odoc-toc"><ul><li><a href="#type-definitions">Type definitions</a></li><li><a href="#standard-functions">Standard functions</a></li><li><a href="#implemented-interfaces">Implemented interfaces</a></li><li><a href="#term-constructor-not-in-implemented-interfaces">Term constructor not in implemented interfaces</a></li><li><a href="#term-inspection">Term inspection</a></li><li><a href="#additional-functions">Additional functions</a></li><li><a href="#term-mapping">Term mapping</a></li></ul></nav><div class="odoc-content"><h3 id="type-definitions"><a href="#type-definitions" class="anchor"></a>Type definitions</h3><div class="odoc-spec"><div class="spec type anchored" id="type-location"><a href="#type-location" class="anchor"></a><code><span><span class="keyword">type</span> location</span><span> = <a href="../Loc/index.html#type-t">Loc.t</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-builtin"><a href="#type-builtin" class="anchor"></a><code><span><span class="keyword">type</span> builtin</span><span> = </span></code><ol><li id="type-builtin.Wildcard" class="def variant constructor anchored"><a href="#type-builtin.Wildcard" class="anchor"></a><code><span>| </span><span><span class="constructor">Wildcard</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Wildcard symbol, i.e placeholder for an expression to be inferred, typically during type-checking.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Ttype" class="def variant constructor anchored"><a href="#type-builtin.Ttype" class="anchor"></a><code><span>| </span><span><span class="constructor">Ttype</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Builtin symbol for the type of Types.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Unit" class="def variant constructor anchored"><a href="#type-builtin.Unit" class="anchor"></a><code><span>| </span><span><span class="constructor">Unit</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Unit type.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Void" class="def variant constructor anchored"><a href="#type-builtin.Void" class="anchor"></a><code><span>| </span><span><span class="constructor">Void</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Only inhabitant of the unit type.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Prop" class="def variant constructor anchored"><a href="#type-builtin.Prop" class="anchor"></a><code><span>| </span><span><span class="constructor">Prop</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Builtin symbol for the type of propositions.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Bool" class="def variant constructor anchored"><a href="#type-builtin.Bool" class="anchor"></a><code><span>| </span><span><span class="constructor">Bool</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The boolean type.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.True" class="def variant constructor anchored"><a href="#type-builtin.True" class="anchor"></a><code><span>| </span><span><span class="constructor">True</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The <code>true</code> propositional constant.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.False" class="def variant constructor anchored"><a href="#type-builtin.False" class="anchor"></a><code><span>| </span><span><span class="constructor">False</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The <code>false</code> propositional constant.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Eq" class="def variant constructor anchored"><a href="#type-builtin.Eq" class="anchor"></a><code><span>| </span><span><span class="constructor">Eq</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Should all arguments be pariwise equal ?</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Distinct" class="def variant constructor anchored"><a href="#type-builtin.Distinct" class="anchor"></a><code><span>| </span><span><span class="constructor">Distinct</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Should all arguments be pairwise distinct ?</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Ite" class="def variant constructor anchored"><a href="#type-builtin.Ite" class="anchor"></a><code><span>| </span><span><span class="constructor">Ite</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Condional, usually applied to 3 terms (the condition, the then branch and the else branch).</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Sequent" class="def variant constructor anchored"><a href="#type-builtin.Sequent" class="anchor"></a><code><span>| </span><span><span class="constructor">Sequent</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Sequent as term, usually takes two argument (left side, and right side of the sequent), which are respectively a conjunction and a disjunction of propositional formulas.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Int" class="def variant constructor anchored"><a href="#type-builtin.Int" class="anchor"></a><code><span>| </span><span><span class="constructor">Int</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Builtin integer type. Currently specific to Zipperposition and alt-ergo format; other languages might use constants with pre-defined name, such as tptp's &quot;$int&quot;.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Real" class="def variant constructor anchored"><a href="#type-builtin.Real" class="anchor"></a><code><span>| </span><span><span class="constructor">Real</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Builtin real type. Currently specific to Alt-ergo format; other languages might use constants with pre-defined name, such as smtlib's &quot;real&quot;.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Minus" class="def variant constructor anchored"><a href="#type-builtin.Minus" class="anchor"></a><code><span>| </span><span><span class="constructor">Minus</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Arithmetic unary minus.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Add" class="def variant constructor anchored"><a href="#type-builtin.Add" class="anchor"></a><code><span>| </span><span><span class="constructor">Add</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Arithmetic addition.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Sub" class="def variant constructor anchored"><a href="#type-builtin.Sub" class="anchor"></a><code><span>| </span><span><span class="constructor">Sub</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Arithmetic substraction.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Mult" class="def variant constructor anchored"><a href="#type-builtin.Mult" class="anchor"></a><code><span>| </span><span><span class="constructor">Mult</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Arithmetic multiplication.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Div" class="def variant constructor anchored"><a href="#type-builtin.Div" class="anchor"></a><code><span>| </span><span><span class="constructor">Div</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Arithmetic division quotient</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Mod" class="def variant constructor anchored"><a href="#type-builtin.Mod" class="anchor"></a><code><span>| </span><span><span class="constructor">Mod</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Arithmetic division modulo</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Int_pow" class="def variant constructor anchored"><a href="#type-builtin.Int_pow" class="anchor"></a><code><span>| </span><span><span class="constructor">Int_pow</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Integer exponentiation.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Real_pow" class="def variant constructor anchored"><a href="#type-builtin.Real_pow" class="anchor"></a><code><span>| </span><span><span class="constructor">Real_pow</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Real exponentiation.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Lt" class="def variant constructor anchored"><a href="#type-builtin.Lt" class="anchor"></a><code><span>| </span><span><span class="constructor">Lt</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Arithmetic &quot;less than&quot; comparison (strict).</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Leq" class="def variant constructor anchored"><a href="#type-builtin.Leq" class="anchor"></a><code><span>| </span><span><span class="constructor">Leq</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Arithmetic &quot;lesser or equal&quot; comparison.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Gt" class="def variant constructor anchored"><a href="#type-builtin.Gt" class="anchor"></a><code><span>| </span><span><span class="constructor">Gt</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Arithmetic &quot;greater than&quot; comparison.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Geq" class="def variant constructor anchored"><a href="#type-builtin.Geq" class="anchor"></a><code><span>| </span><span><span class="constructor">Geq</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Arithmetic &quot;greater or equal&quot; comparison.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Subtype" class="def variant constructor anchored"><a href="#type-builtin.Subtype" class="anchor"></a><code><span>| </span><span><span class="constructor">Subtype</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Subtyping relation</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Product" class="def variant constructor anchored"><a href="#type-builtin.Product" class="anchor"></a><code><span>| </span><span><span class="constructor">Product</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Product type constructor</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Union" class="def variant constructor anchored"><a href="#type-builtin.Union" class="anchor"></a><code><span>| </span><span><span class="constructor">Union</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Union type constructor</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Pi" class="def variant constructor anchored"><a href="#type-builtin.Pi" class="anchor"></a><code><span>| </span><span><span class="constructor">Pi</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Pi: higher-order encoding of the forall quantifier as a constant.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Sigma" class="def variant constructor anchored"><a href="#type-builtin.Sigma" class="anchor"></a><code><span>| </span><span><span class="constructor">Sigma</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Sigma: higher-order envoding of the exists quantifier of a constant.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Not" class="def variant constructor anchored"><a href="#type-builtin.Not" class="anchor"></a><code><span>| </span><span><span class="constructor">Not</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Propositional negation</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.And" class="def variant constructor anchored"><a href="#type-builtin.And" class="anchor"></a><code><span>| </span><span><span class="constructor">And</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Propositional conjunction</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Or" class="def variant constructor anchored"><a href="#type-builtin.Or" class="anchor"></a><code><span>| </span><span><span class="constructor">Or</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Propositional disjunction</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Nand" class="def variant constructor anchored"><a href="#type-builtin.Nand" class="anchor"></a><code><span>| </span><span><span class="constructor">Nand</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Propositional not-and connective</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Xor" class="def variant constructor anchored"><a href="#type-builtin.Xor" class="anchor"></a><code><span>| </span><span><span class="constructor">Xor</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Propositional exclusive disjunction</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Nor" class="def variant constructor anchored"><a href="#type-builtin.Nor" class="anchor"></a><code><span>| </span><span><span class="constructor">Nor</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Propositional not-or</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Imply" class="def variant constructor anchored"><a href="#type-builtin.Imply" class="anchor"></a><code><span>| </span><span><span class="constructor">Imply</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Propositional implication</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Implied" class="def variant constructor anchored"><a href="#type-builtin.Implied" class="anchor"></a><code><span>| </span><span><span class="constructor">Implied</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Propositional left implication (i.e implication with reversed arguments).</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Equiv" class="def variant constructor anchored"><a href="#type-builtin.Equiv" class="anchor"></a><code><span>| </span><span><span class="constructor">Equiv</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Propositional equivalence</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Bitv" class="def variant constructor anchored"><a href="#type-builtin.Bitv" class="anchor"></a><code><span>| </span><span><span class="constructor">Bitv</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bitvector type (with given length)</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Bitv_extract" class="def variant constructor anchored"><a href="#type-builtin.Bitv_extract" class="anchor"></a><code><span>| </span><span><span class="constructor">Bitv_extract</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bitvector extraction</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Bitv_concat" class="def variant constructor anchored"><a href="#type-builtin.Bitv_concat" class="anchor"></a><code><span>| </span><span><span class="constructor">Bitv_concat</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bitvector concatenation</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Array_get" class="def variant constructor anchored"><a href="#type-builtin.Array_get" class="anchor"></a><code><span>| </span><span><span class="constructor">Array_get</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Array getter.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Array_set" class="def variant constructor anchored"><a href="#type-builtin.Array_set" class="anchor"></a><code><span>| </span><span><span class="constructor">Array_set</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Array setter.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Adt_check" class="def variant constructor anchored"><a href="#type-builtin.Adt_check" class="anchor"></a><code><span>| </span><span><span class="constructor">Adt_check</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Algebraic datatype head constructore checker.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Adt_project" class="def variant constructor anchored"><a href="#type-builtin.Adt_project" class="anchor"></a><code><span>| </span><span><span class="constructor">Adt_project</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Algebraic datatype projection.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Record" class="def variant constructor anchored"><a href="#type-builtin.Record" class="anchor"></a><code><span>| </span><span><span class="constructor">Record</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Record creation</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Record_with" class="def variant constructor anchored"><a href="#type-builtin.Record_with" class="anchor"></a><code><span>| </span><span><span class="constructor">Record_with</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Record &quot;with&quot; creation</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Record_access" class="def variant constructor anchored"><a href="#type-builtin.Record_access" class="anchor"></a><code><span>| </span><span><span class="constructor">Record_access</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Record field access</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Maps_to" class="def variant constructor anchored"><a href="#type-builtin.Maps_to" class="anchor"></a><code><span>| </span><span><span class="constructor">Maps_to</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Mapping; used in Alt-ergo triggers.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.In_interval" class="def variant constructor anchored"><a href="#type-builtin.In_interval" class="anchor"></a><code><span>| </span><span><span class="constructor">In_interval</span> <span class="keyword">of</span> bool * bool</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Interval check; used in Alt-ergo triggers</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Check" class="def variant constructor anchored"><a href="#type-builtin.Check" class="anchor"></a><code><span>| </span><span><span class="constructor">Check</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Similar to cut, but does not introduce the proved term into the axioms.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Cut" class="def variant constructor anchored"><a href="#type-builtin.Cut" class="anchor"></a><code><span>| </span><span><span class="constructor">Cut</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Insert a cut of the given term.</p><span class="comment-delim">*)</span></div></li><li id="type-builtin.Sexpr" class="def variant constructor anchored"><a href="#type-builtin.Sexpr" class="anchor"></a><code><span>| </span><span><span class="constructor">Sexpr</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Head symbol for s-exprs in smtlib.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>The type of builtins symbols for terms. Some languages have specific syntax for logical connectives (tptp's'&amp;&amp;' or '||' for isntance) whereas some (smtlib for instance) don't and treat them as constants.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-binder"><a href="#type-binder" class="anchor"></a><code><span><span class="keyword">type</span> binder</span><span> = </span></code><ol><li id="type-binder.All" class="def variant constructor anchored"><a href="#type-binder.All" class="anchor"></a><code><span>| </span><span><span class="constructor">All</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Universal quantification. Each term in the list of quantified terms should represent a variable (optionnally typed using the <a href="#type-descr.Colon"><code>Colon</code></a> constructor.</p><span class="comment-delim">*)</span></div></li><li id="type-binder.Ex" class="def variant constructor anchored"><a href="#type-binder.Ex" class="anchor"></a><code><span>| </span><span><span class="constructor">Ex</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Existencial quantification Each term in the list of quantified terms should represent a variable (optionnally typed using the <a href="#type-descr.Colon"><code>Colon</code></a> constructor.</p><span class="comment-delim">*)</span></div></li><li id="type-binder.Pi" class="def variant constructor anchored"><a href="#type-binder.Pi" class="anchor"></a><code><span>| </span><span><span class="constructor">Pi</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Polymorphic type quantification in function type Each term in the list of quantified terms should represent a variable (optionnally typed using the <a href="#type-descr.Colon"><code>Colon</code></a> constructor.</p><span class="comment-delim">*)</span></div></li><li id="type-binder.Arrow" class="def variant constructor anchored"><a href="#type-binder.Arrow" class="anchor"></a><code><span>| </span><span><span class="constructor">Arrow</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The arrow binder, for function types. Allows for curified types, if wanted.</p><span class="comment-delim">*)</span></div></li><li id="type-binder.Let_seq" class="def variant constructor anchored"><a href="#type-binder.Let_seq" class="anchor"></a><code><span>| </span><span><span class="constructor">Let_seq</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Let bindings (either propositional or for terms). Term bound by a let can have many forms depending on the language, but usual shapes are:</p><ul><li>an equality (using the builtin <a href="#type-builtin.Eq"><code>Eq</code></a>) between a variable (optionnally typed using the <a href="#type-descr.Colon"><code>Colon</code></a> constructor), and a term (e.g. in tptp)</li><li>an equivalence (using the builtin <a href="#type-builtin.Equiv"><code>Equiv</code></a>) between a variable (optionnally typed using the <a href="#type-descr.Colon"><code>Colon</code></a> constructor), and a term/proposition (e.g. in tptp)</li><li>a variable and a term juxtaposed using the <a href="#type-descr.Colon"><code>Colon</code></a> constructor (e.g. in smtlib)</li></ul><span class="comment-delim">*)</span></div></li><li id="type-binder.Let_par" class="def variant constructor anchored"><a href="#type-binder.Let_par" class="anchor"></a><code><span>| </span><span><span class="constructor">Let_par</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Similar to <code>Let_seq</code>; except that the list of bindings should be considered all bound at the same time/level/scope. More precisely, for <code>Let_seq</code>, the list of bindings is to be understood sequentially (i.e. <code>Let_seq (b1 :: b2 ...)</code> is semantically the same as <code>Let_seq b1 (Let_seq b2 (..))</code>. For <code>Let_par</code>, the list of bindings all happen at the same time: the defining expressions of each binding cannot refer to other bindings in the same parralel let-binding.</p><span class="comment-delim">*)</span></div></li><li id="type-binder.Fun" class="def variant constructor anchored"><a href="#type-binder.Fun" class="anchor"></a><code><span>| </span><span><span class="constructor">Fun</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Lambda, i.e function abstraction binder. Bound terms are the variables bound by the lambda, optionnally typed using the <a href="#type-descr.Colon"><code>Colon</code></a> constructor.</p><span class="comment-delim">*)</span></div></li><li id="type-binder.Choice" class="def variant constructor anchored"><a href="#type-binder.Choice" class="anchor"></a><code><span>| </span><span><span class="constructor">Choice</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Indefinite description, or epsilon terms. Likely to have its usual shape change following tptp's recent changes.</p><span class="comment-delim">*)</span></div></li><li id="type-binder.Description" class="def variant constructor anchored"><a href="#type-binder.Description" class="anchor"></a><code><span>| </span><span><span class="constructor">Description</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Definite description. Likely to have its usual shape change following tptp's recent changes.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>The type of binders, these are pretty much always builtin in all languages.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-descr"><a href="#type-descr" class="anchor"></a><code><span><span class="keyword">type</span> descr</span><span> = </span></code><ol><li id="type-descr.Symbol" class="def variant constructor anchored"><a href="#type-descr.Symbol" class="anchor"></a><code><span>| </span><span><span class="constructor">Symbol</span> <span class="keyword">of</span> <a href="../Id/index.html#type-t">Id.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Constants, variables, etc... any string-identified non-builtin atomic term.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Builtin" class="def variant constructor anchored"><a href="#type-descr.Builtin" class="anchor"></a><code><span>| </span><span><span class="constructor">Builtin</span> <span class="keyword">of</span> <a href="#type-builtin">builtin</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Predefined builtins, i.e constants with lexical or syntaxic defintion in the source language.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Colon" class="def variant constructor anchored"><a href="#type-descr.Colon" class="anchor"></a><code><span>| </span><span><span class="constructor">Colon</span> <span class="keyword">of</span> <a href="#type-t">t</a> * <a href="#type-t">t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Juxtaposition of terms, usually used to annotate a term with its type (for quantified variables, functions arguments, etc...).</p><span class="comment-delim">*)</span></div></li><li id="type-descr.App" class="def variant constructor anchored"><a href="#type-descr.App" class="anchor"></a><code><span>| </span><span><span class="constructor">App</span> <span class="keyword">of</span> <a href="#type-t">t</a> * <span><a href="#type-t">t</a> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Higher-order application</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Binder" class="def variant constructor anchored"><a href="#type-descr.Binder" class="anchor"></a><code><span>| </span><span><span class="constructor">Binder</span> <span class="keyword">of</span> <a href="#type-binder">binder</a> * <span><a href="#type-t">t</a> list</span> * <a href="#type-t">t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Binder (quantifiers, local functions, ...), see the <a href="#type-mapper.binder"><code>binder</code></a> type for more information.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Match" class="def variant constructor anchored"><a href="#type-descr.Match" class="anchor"></a><code><span>| </span><span><span class="constructor">Match</span> <span class="keyword">of</span> <a href="#type-t">t</a> * <span><span>(<a href="#type-t">t</a> * <a href="#type-t">t</a>)</span> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Pattern matching, the list contains tuples of the form <code>(pattern,branch)</code>.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>The AST for terms</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">and</span> t</span><span> = </span><span>{</span></code><ol><li id="type-t.term" class="def record field anchored"><a href="#type-t.term" class="anchor"></a><code><span>term : <a href="#type-descr">descr</a>;</span></code></li><li id="type-t.attr" class="def record field anchored"><a href="#type-t.attr" class="anchor"></a><code><span>attr : <span><a href="#type-t">t</a> list</span>;</span></code></li><li id="type-t.loc" class="def record field anchored"><a href="#type-t.loc" class="anchor"></a><code><span>loc : <a href="#type-location">location</a>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>The type of terms. A record containing an optional location, and a description of the term.</p></div></div><h3 id="standard-functions"><a href="#standard-functions" class="anchor"></a>Standard functions</h3><div class="odoc-spec"><div class="spec value anchored" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Equality and comparison</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print"><a href="#val-print" class="anchor"></a><code><span><span class="keyword">val</span> print : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_builtin"><a href="#val-print_builtin" class="anchor"></a><code><span><span class="keyword">val</span> print_builtin : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-builtin">builtin</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Printing functionson buffer and formatters.</p></div></div><h3 id="implemented-interfaces"><a href="#implemented-interfaces" class="anchor"></a>Implemented interfaces</h3><div class="odoc-include"><div class="spec-doc"><p>Include the Logic interface. This interface defines almost all term building functions that you may want to use.</p></div><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../Dolmen_intf/Term/module-type-Logic/index.html">Dolmen_intf.Term.Logic</a>
  <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../Dolmen_intf/Term/module-type-Logic/index.html#type-t">t</a> := <a href="#type-t">t</a></span>
   <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../../Dolmen_intf/Term/module-type-Logic/index.html#type-id">id</a> := <a href="../Id/index.html#type-t">Id.t</a></span>
   <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../../Dolmen_intf/Term/module-type-Logic/index.html#type-location">location</a> := <a href="#type-location">location</a></span></span></code></summary><h4 id="predefined-terms"><a href="#predefined-terms" class="anchor"></a>Predefined terms</h4><div class="odoc-spec"><div class="spec value anchored" id="val-eq_t"><a href="#val-eq_t" class="anchor"></a><code><span><span class="keyword">val</span> eq_t : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-neq_t"><a href="#val-neq_t" class="anchor"></a><code><span><span class="keyword">val</span> neq_t : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>The terms representing equality and disequality, respectively.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-wildcard"><a href="#val-wildcard" class="anchor"></a><code><span><span class="keyword">val</span> wildcard : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>The wildcard term, usually used in place of type arguments to explicit polymorphic functions to not explicit types that can be inferred by the type-checker.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tType"><a href="#val-tType" class="anchor"></a><code><span><span class="keyword">val</span> tType : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>The type of types, defined as specific token by the Zipperposition format; in other languages, will be represented as a constant (the &quot;$tType&quot; constant in tptp for instance). Used to define new types, or quantify type variables in languages that support polymorphism.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prop"><a href="#val-prop" class="anchor"></a><code><span><span class="keyword">val</span> prop : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>The type of propositions. Also defined as a lexical token by the Zipperposition format. Will be defined as a constant in most other languages (for instance, &quot;$o&quot; in tptp).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bool"><a href="#val-bool" class="anchor"></a><code><span><span class="keyword">val</span> bool : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>The type of boolean, defined as a specific token by the Alt-ergo format; in other languages, it might be represented as a constant with a specific name.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ty_unit"><a href="#val-ty_unit" class="anchor"></a><code><span><span class="keyword">val</span> ty_unit : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>The type unit, defined as a specific token by the Alt-ergo format; in other languages, it might be represented as a constant with a specific name.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ty_int"><a href="#val-ty_int" class="anchor"></a><code><span><span class="keyword">val</span> ty_int : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>The type of integers, defined as a specific token by the Zipperposition and Alt-ergo formats; in other languages, it might be represented as a constant with a specific name (for isntance, tptp's &quot;$int&quot;) .</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ty_real"><a href="#val-ty_real" class="anchor"></a><code><span><span class="keyword">val</span> ty_real : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>The type of integers, defined as a specific token by the Alt-ergo format; in other languages, it might be represented as a constant with a specific name (for isntance, tptp's &quot;$int&quot;) .</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ty_bitv"><a href="#val-ty_bitv" class="anchor"></a><code><span><span class="keyword">val</span> ty_bitv : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>The type of bitvectors of the given constant length, defined as a specifi token by the Alt-ergo format; in other languages, it might be represented as a constant with a specific name (for isntance, smtlib(s &quot;bitv&quot;) .</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-void"><a href="#val-void" class="anchor"></a><code><span><span class="keyword">val</span> void : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>The only value of type unit, defined as a specific token by the Alt-ergo format.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-true_"><a href="#val-true_" class="anchor"></a><code><span><span class="keyword">val</span> true_ : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-false_"><a href="#val-false_" class="anchor"></a><code><span><span class="keyword">val</span> false_ : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>The constants for the true and false propositional constants. Again defined as lexical token in the Zipperposition format, while treated as a constant in other languages (&quot;$true&quot; in tptp).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-not_t"><a href="#val-not_t" class="anchor"></a><code><span><span class="keyword">val</span> not_t : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-or_t"><a href="#val-or_t" class="anchor"></a><code><span><span class="keyword">val</span> or_t : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-and_t"><a href="#val-and_t" class="anchor"></a><code><span><span class="keyword">val</span> and_t : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-xor_t"><a href="#val-xor_t" class="anchor"></a><code><span><span class="keyword">val</span> xor_t : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nor_t"><a href="#val-nor_t" class="anchor"></a><code><span><span class="keyword">val</span> nor_t : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nand_t"><a href="#val-nand_t" class="anchor"></a><code><span><span class="keyword">val</span> nand_t : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equiv_t"><a href="#val-equiv_t" class="anchor"></a><code><span><span class="keyword">val</span> equiv_t : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-implied_t"><a href="#val-implied_t" class="anchor"></a><code><span><span class="keyword">val</span> implied_t : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-implies_t"><a href="#val-implies_t" class="anchor"></a><code><span><span class="keyword">val</span> implies_t : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pi_t"><a href="#val-pi_t" class="anchor"></a><code><span><span class="keyword">val</span> pi_t : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sigma_t"><a href="#val-sigma_t" class="anchor"></a><code><span><span class="keyword">val</span> sigma_t : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Standard logical connectives viewed as terms. <code>implies_t</code> is usual right implication, i.e <code>apply implies_t [p; q] </code> is &quot;p implies q&quot;, while <code>apply implied_t [p; q ]</code> means &quot;p is implied by q&quot; or &quot;q implies p&quot;.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-data_t"><a href="#val-data_t" class="anchor"></a><code><span><span class="keyword">val</span> data_t : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Term without semantic meaning, used for creating &quot;data&quot; terms. Used in tptp's annotations, and with similar meaning as smtlib's s-expressions (as used in the <code>sexpr</code> function defined later).</p></div></div><h4 id="terms-leaf-constructors"><a href="#terms-leaf-constructors" class="anchor"></a>Terms leaf constructors</h4><div class="odoc-spec"><div class="spec value anchored" id="val-var"><a href="#val-var" class="anchor"></a><code><span><span class="keyword">val</span> var : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-const"><a href="#val-const" class="anchor"></a><code><span><span class="keyword">val</span> const : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Variable and constant constructors. While in some languages they can distinguished at the lexical level (in tptp for instance), in most languages, it is an issue dependant on scoping rules, so terms parsed from an smtlib file will have all variables parsed as constants.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-atom"><a href="#val-atom" class="anchor"></a><code><span><span class="keyword">val</span> atom : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Atoms are used for dimacs cnf parsing. Positive integers denotes variables, and negative integers denote the negation of the variable corresponding to their absolute value.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-distinct"><a href="#val-distinct" class="anchor"></a><code><span><span class="keyword">val</span> distinct : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Used in tptp to specify constants different from other constants, for instance the 'distinct' &quot;Apple&quot; should be syntactically different from the &quot;Apple&quot; constant. Can be safely aliased to the <code>const</code> function as the <code>distinct</code> function is always given strings already enclosed with quotes, so in the example above, <code>const</code> would be called with <code>&quot;Apple&quot;</code> as string argument, while <code>distinct</code> would be called with the string <code>&quot;\&quot;Apple\&quot;&quot;</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-str"><a href="#val-str" class="anchor"></a><code><span><span class="keyword">val</span> str : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int"><a href="#val-int" class="anchor"></a><code><span><span class="keyword">val</span> int : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rat"><a href="#val-rat" class="anchor"></a><code><span><span class="keyword">val</span> rat : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-real"><a href="#val-real" class="anchor"></a><code><span><span class="keyword">val</span> real : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hexa"><a href="#val-hexa" class="anchor"></a><code><span><span class="keyword">val</span> hexa : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-binary"><a href="#val-binary" class="anchor"></a><code><span><span class="keyword">val</span> binary : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Constructors for words defined as numeric or string formats by the languages specifications. These also can be safely aliased to <code>const</code>, but then the provenance information is lost, which might complicate the task of a type-checker.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bitv"><a href="#val-bitv" class="anchor"></a><code><span><span class="keyword">val</span> bitv : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Bitvetor literal, defined as a specific token in Alt-ergo; Expects a decimal integer in the string to be extended as a bitvector.</p></div></div><h4 id="term-constructors"><a href="#term-constructors" class="anchor"></a>Term constructors</h4><div class="odoc-spec"><div class="spec value anchored" id="val-colon"><a href="#val-colon" class="anchor"></a><code><span><span class="keyword">val</span> colon : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Represents juxtaposition of two terms, usually denoted &quot;t : t'&quot; in most languages, and mainly used to annotated terms with their supposed, or defined, type.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eq"><a href="#val-eq" class="anchor"></a><code><span><span class="keyword">val</span> eq : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-neq"><a href="#val-neq" class="anchor"></a><code><span><span class="keyword">val</span> neq : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Equality and dis-equality of terms.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-not_"><a href="#val-not_" class="anchor"></a><code><span><span class="keyword">val</span> not_ : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-or_"><a href="#val-or_" class="anchor"></a><code><span><span class="keyword">val</span> or_ : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-and_"><a href="#val-and_" class="anchor"></a><code><span><span class="keyword">val</span> and_ : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-xor"><a href="#val-xor" class="anchor"></a><code><span><span class="keyword">val</span> xor : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-imply"><a href="#val-imply" class="anchor"></a><code><span><span class="keyword">val</span> imply : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equiv"><a href="#val-equiv" class="anchor"></a><code><span><span class="keyword">val</span> equiv : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Proposition construction functions. The conjunction and disjunction are n-ary instead of binary mostly because they are in smtlib (and that is subsumes the binary case).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-apply"><a href="#val-apply" class="anchor"></a><code><span><span class="keyword">val</span> apply : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Application constructor, seen as higher order application rather than first-order application for the following reasons: being able to parse tptp's THF, having location attached to function symbols.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ite"><a href="#val-ite" class="anchor"></a><code><span><span class="keyword">val</span> ite : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Conditional constructor, both for first-order terms and propositions. Used in the following schema: <code>ite condition then_branch else_branch</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-match_"><a href="#val-match_" class="anchor"></a><code><span><span class="keyword">val</span> match_ : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="#type-t">t</a> * <a href="#type-t">t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Pattern matching. The first term is the term to match, and each tuple in the list is a match case, which is a pair of a pattern and a match branch.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pi"><a href="#val-pi" class="anchor"></a><code><span><span class="keyword">val</span> pi : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-par"><a href="#val-par" class="anchor"></a><code><span><span class="keyword">val</span> par : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-letin"><a href="#val-letin" class="anchor"></a><code><span><span class="keyword">val</span> letin : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-letand"><a href="#val-letand" class="anchor"></a><code><span><span class="keyword">val</span> letand : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-forall"><a href="#val-forall" class="anchor"></a><code><span><span class="keyword">val</span> forall : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span><span class="keyword">val</span> exists : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lambda"><a href="#val-lambda" class="anchor"></a><code><span><span class="keyword">val</span> lambda : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-choice"><a href="#val-choice" class="anchor"></a><code><span><span class="keyword">val</span> choice : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-description"><a href="#val-description" class="anchor"></a><code><span><span class="keyword">val</span> description : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Binders for variables. Takes a list of terms as first argument for simplicity, the lists will almost always be a list of variables, optionally typed using the <code>colon</code> term constructor.</p><ul><li>Pi is the polymorphic type quantification, for instance the polymorphic identity function has type: &quot;Pi alpha. alpha -&gt; alpha&quot;</li><li>Letin is local binding, takes a list of equality of equivalences whose left hand-side is a variable. Letand is the parrallel version of Letin.</li><li>Forall is universal quantification</li><li>Par is universal quantification over type variables specifically (i.e. the same as forall, but only for a list of type variables, which thus may omit the <code>colon</code> annotations in the arguments).</li><li>Exists is existential quantification</li><li>Lambda is used for function construction</li><li>Choice is the choice operator, also called indefinite description, or also epsilon terms, i.e &quot;Choice x. p(x)&quot; is one &quot;x&quot; such that &quot;p(x)&quot; is true.</li><li>Description is the definite description, i.e &quot;Description x. p(x)&quot; is the <b>only</b> &quot;x&quot; that satisfies p.</li></ul></div></div><h4 id="type-constructors"><a href="#type-constructors" class="anchor"></a>Type constructors</h4><div class="odoc-spec"><div class="spec value anchored" id="val-arrow"><a href="#val-arrow" class="anchor"></a><code><span><span class="keyword">val</span> arrow : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Function type constructor, for curryfied functions. Functions that takes multiple arguments in first-order terms might take a product as only argument (see the following <code>product</code> function) in some languages (e.g. tptp), or be curryfied using this constructor in other languages (e.g. alt-ergo).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-product"><a href="#val-product" class="anchor"></a><code><span><span class="keyword">val</span> product : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Product type constructor, used for instance in the types of functions that takes multiple arguments in a non-curry way.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-union"><a href="#val-union" class="anchor"></a><code><span><span class="keyword">val</span> union : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Union type constructor, currently used in tptp's THF format.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-subtype"><a href="#val-subtype" class="anchor"></a><code><span><span class="keyword">val</span> subtype : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Subtype relation for types.</p></div></div><h4 id="record-constructors"><a href="#record-constructors" class="anchor"></a>Record constructors</h4><div class="odoc-spec"><div class="spec value anchored" id="val-record"><a href="#val-record" class="anchor"></a><code><span><span class="keyword">val</span> record : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a record expression.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-record_with"><a href="#val-record_with" class="anchor"></a><code><span><span class="keyword">val</span> record_with : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Record &quot;with&quot; update (e.g. &quot;<code> r with ....</code>&quot;).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-record_access"><a href="#val-record_access" class="anchor"></a><code><span><span class="keyword">val</span> record_access : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Field record access.</p></div></div><h4 id="algebraic-datatypes"><a href="#algebraic-datatypes" class="anchor"></a>Algebraic datatypes</h4><div class="odoc-spec"><div class="spec value anchored" id="val-adt_check"><a href="#val-adt_check" class="anchor"></a><code><span><span class="keyword">val</span> adt_check : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Check whether some expression matches a given adt constructor (in head position).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-adt_project"><a href="#val-adt_project" class="anchor"></a><code><span><span class="keyword">val</span> adt_project : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Project a field of an adt constructor (usually unsafe except when guarded by an adt_check function).</p></div></div><h4 id="array-constructors"><a href="#array-constructors" class="anchor"></a>Array constructors</h4><div class="odoc-spec"><div class="spec value anchored" id="val-array_get"><a href="#val-array_get" class="anchor"></a><code><span><span class="keyword">val</span> array_get : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Array getter.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-array_set"><a href="#val-array_set" class="anchor"></a><code><span><span class="keyword">val</span> array_set : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Array setter.</p></div></div><h4 id="bitvector-constructors"><a href="#bitvector-constructors" class="anchor"></a>Bitvector constructors</h4><div class="odoc-spec"><div class="spec value anchored" id="val-bitv_extract"><a href="#val-bitv_extract" class="anchor"></a><code><span><span class="keyword">val</span> bitv_extract : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Bitvector extraction.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bitv_concat"><a href="#val-bitv_concat" class="anchor"></a><code><span><span class="keyword">val</span> bitv_concat : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Bitvector concatenation.</p></div></div><h4 id="arithmetic-constructors"><a href="#arithmetic-constructors" class="anchor"></a>Arithmetic constructors</h4><div class="odoc-spec"><div class="spec value anchored" id="val-uminus"><a href="#val-uminus" class="anchor"></a><code><span><span class="keyword">val</span> uminus : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Arithmetic unary minus.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Arithmetic addition.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span><span class="keyword">val</span> sub : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Arithmetic substraction.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mult"><a href="#val-mult" class="anchor"></a><code><span><span class="keyword">val</span> mult : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Arithmetic multiplication.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-div"><a href="#val-div" class="anchor"></a><code><span><span class="keyword">val</span> div : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Arithmetic division quotient.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mod_"><a href="#val-mod_" class="anchor"></a><code><span><span class="keyword">val</span> mod_ : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Arithmetic modulo (aka division reminder).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int_pow"><a href="#val-int_pow" class="anchor"></a><code><span><span class="keyword">val</span> int_pow : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Integer power.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-real_pow"><a href="#val-real_pow" class="anchor"></a><code><span><span class="keyword">val</span> real_pow : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Real power.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lt"><a href="#val-lt" class="anchor"></a><code><span><span class="keyword">val</span> lt : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Arithmetic &quot;lesser than&quot; comparison (strict).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-leq"><a href="#val-leq" class="anchor"></a><code><span><span class="keyword">val</span> leq : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Arithmetic &quot;lesser or equal&quot; comparison.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-gt"><a href="#val-gt" class="anchor"></a><code><span><span class="keyword">val</span> gt : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Arithmetic &quot;greater than&quot; comparison (strict).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-geq"><a href="#val-geq" class="anchor"></a><code><span><span class="keyword">val</span> geq : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Arithmetic &quot;greater or equal&quot; comparison.</p></div></div><h4 id="triggers"><a href="#triggers" class="anchor"></a>Triggers</h4><div class="odoc-spec"><div class="spec value anchored" id="val-in_interval"><a href="#val-in_interval" class="anchor"></a><code><span><span class="keyword">val</span> in_interval : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-t">t</a> * bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-t">t</a> * bool)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a predicate for whether a term is within the given bounds (each bound is represented by a term which is tis value and a boolean which specifies whether it is strict or not).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-maps_to"><a href="#val-maps_to" class="anchor"></a><code><span><span class="keyword">val</span> maps_to : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Id mapping (see alt-ergo).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-trigger"><a href="#val-trigger" class="anchor"></a><code><span><span class="keyword">val</span> trigger : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a multi-trigger (i.e. all terms in the lsit must match to trigger).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-triggers"><a href="#val-triggers" class="anchor"></a><code><span><span class="keyword">val</span> triggers : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>triggers ~loc f l</code> annotates formula/term <code>f</code> with a list of triggers.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filters"><a href="#val-filters" class="anchor"></a><code><span><span class="keyword">val</span> filters : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>filters ~loc f l</code> annotates formula/term <code>f</code> with a list of filters.</p></div></div><h4 id="special-constructions"><a href="#special-constructions" class="anchor"></a>Special constructions</h4><div class="odoc-spec"><div class="spec value anchored" id="val-tracked"><a href="#val-tracked" class="anchor"></a><code><span><span class="keyword">val</span> tracked : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Name a term for tracking purposes.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-quoted"><a href="#val-quoted" class="anchor"></a><code><span><span class="keyword">val</span> quoted : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create an attribute from a quoted string (in Zf).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sequent"><a href="#val-sequent" class="anchor"></a><code><span><span class="keyword">val</span> sequent : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Sequents as terms</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-check"><a href="#val-check" class="anchor"></a><code><span><span class="keyword">val</span> check : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Check a term (see alt-ergo).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cut"><a href="#val-cut" class="anchor"></a><code><span><span class="keyword">val</span> cut : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a cut (see alt-ergo).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-annot"><a href="#val-annot" class="anchor"></a><code><span><span class="keyword">val</span> annot : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Attach a list of attributes (also called annotations) to a term. Attributes have no logical meaning (they can be safely ignored), but may serve to give hints or meta-information.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexpr"><a href="#val-sexpr" class="anchor"></a><code><span><span class="keyword">val</span> sexpr : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>S-expressions (for smtlib attributes), should probably be related to the <code>data_t</code> term.</p></div></div></details></div><h3 id="term-constructor-not-in-implemented-interfaces"><a href="#term-constructor-not-in-implemented-interfaces" class="anchor"></a>Term constructor not in implemented interfaces</h3><div class="odoc-spec"><div class="spec value anchored" id="val-ite_t"><a href="#val-ite_t" class="anchor"></a><code><span><span class="keyword">val</span> ite_t : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>The standalone term corresponding to the if-then-else builtin construction.</p></div></div><h3 id="term-inspection"><a href="#term-inspection" class="anchor"></a>Term inspection</h3><div class="odoc-spec"><div class="spec value anchored" id="val-fv"><a href="#val-fv" class="anchor"></a><code><span><span class="keyword">val</span> fv : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> list</span></span></code></div><div class="spec-doc"><p>Return the list of free variables (i.e currently, Ids that are in the <code>Var</code> namespace).</p></div></div><h3 id="additional-functions"><a href="#additional-functions" class="anchor"></a>Additional functions</h3><div class="odoc-spec"><div class="spec value anchored" id="val-builtin"><a href="#val-builtin" class="anchor"></a><code><span><span class="keyword">val</span> builtin : <span><a href="#type-builtin">builtin</a> <span class="arrow">&#45;&gt;</span></span> <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Make a builtin.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fun_ty"><a href="#val-fun_ty" class="anchor"></a><code><span><span class="keyword">val</span> fun_ty : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Multi-arguments function type constructor.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_attr"><a href="#val-add_attr" class="anchor"></a><code><span><span class="keyword">val</span> add_attr : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>add_attr attr term</code> rturns a term <code>t</code> equal to <code>term</code>, but with <code>attr</code> added to the list of attributes.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_attrs"><a href="#val-add_attrs" class="anchor"></a><code><span><span class="keyword">val</span> add_attrs : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Same as <code>add_attr</code> but adds a list of attributes.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_attrs"><a href="#val-set_attrs" class="anchor"></a><code><span><span class="keyword">val</span> set_attrs : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Set the given list of terms as th attributes of the given term. Will fail (with an assertion) if the given term already have some assertion. In such cases, use add_attr instead.</p></div></div><h3 id="term-mapping"><a href="#term-mapping" class="anchor"></a>Term mapping</h3><p>The main use of terms mapper is to map fuctions over some terms. Traditionally, a mapping will usually only care about a few syntax cases and leave all other untouched. In these cases, it is useful to override the identity mapper, redefining only the fields needed.</p><div class="odoc-spec"><div class="spec type anchored" id="type-mapper"><a href="#type-mapper" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a mapper</span></span><span> = </span><span>{</span></code><ol><li id="type-mapper.symbol" class="def record field anchored"><a href="#type-mapper.symbol" class="anchor"></a><code><span>symbol : <span><span><span class="type-var">'a</span> <a href="#type-mapper">mapper</a></span> <span class="arrow">&#45;&gt;</span></span> <span>attr:<span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>;</span></code></li><li id="type-mapper.builtin" class="def record field anchored"><a href="#type-mapper.builtin" class="anchor"></a><code><span>builtin : <span><span><span class="type-var">'a</span> <a href="#type-mapper">mapper</a></span> <span class="arrow">&#45;&gt;</span></span> <span>attr:<span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-builtin">builtin</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>;</span></code></li><li id="type-mapper.colon" class="def record field anchored"><a href="#type-mapper.colon" class="anchor"></a><code><span>colon : <span><span><span class="type-var">'a</span> <a href="#type-mapper">mapper</a></span> <span class="arrow">&#45;&gt;</span></span> <span>attr:<span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>;</span></code></li><li id="type-mapper.app" class="def record field anchored"><a href="#type-mapper.app" class="anchor"></a><code><span>app : <span><span><span class="type-var">'a</span> <a href="#type-mapper">mapper</a></span> <span class="arrow">&#45;&gt;</span></span> <span>attr:<span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>;</span></code></li><li id="type-mapper.binder" class="def record field anchored"><a href="#type-mapper.binder" class="anchor"></a><code><span>binder : <span><span><span class="type-var">'a</span> <a href="#type-mapper">mapper</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>attr:<span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-binder">binder</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span>;</span></code></li><li id="type-mapper.pmatch" class="def record field anchored"><a href="#type-mapper.pmatch" class="anchor"></a><code><span>pmatch : <span><span><span class="type-var">'a</span> <a href="#type-mapper">mapper</a></span> <span class="arrow">&#45;&gt;</span></span> <span>attr:<span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="#type-t">t</a> * <a href="#type-t">t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>The type of a mapper on terms.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-id_mapper"><a href="#val-id_mapper" class="anchor"></a><code><span><span class="keyword">val</span> id_mapper : <span><a href="#type-t">t</a> <a href="#type-mapper">mapper</a></span></span></code></div><div class="spec-doc"><p>The identity mapper: maps any term to itself.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unit_mapper"><a href="#val-unit_mapper" class="anchor"></a><code><span><span class="keyword">val</span> unit_mapper : <span>unit <a href="#type-mapper">mapper</a></span></span></code></div><div class="spec-doc"><p>The unit mapper, i.e. an iterator.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span><span class="type-var">'a</span> <a href="#type-mapper">mapper</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Apply a mapper to a term.</p></div></div></div></body></html>