<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Statement (dolmen.Dolmen_std.Statement)</title><link rel="stylesheet" href="../../../_odoc_support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../_odoc_support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">dolmen</a> &#x00BB; <a href="../index.html">Dolmen_std</a> &#x00BB; Statement</nav><header class="odoc-preamble"><h1>Module <code><span>Dolmen_std.Statement</span></code></h1><p>Standard imlplementation of statements. This module provides a reasonable and standard implementation of statements, that can directly be used to instantiated the various functors of the dolmen library. These statements are closer to smtlib statements than to other languages statements because it is easier to express other languages statements using smtlib's than the other way around. Still, a generalisation of smtlib statements was needed so as not to lose some important distinctions between conjectures and assertions for instance.</p></header><nav class="odoc-toc"><ul><li><a href="#type-definitions">Type definitions</a></li><li><a href="#implemented-interfaces">Implemented interfaces</a></li><li><a href="#additional-functions">Additional functions</a></li><li><a href="#printing-functions">Printing functions</a></li></ul></nav><div class="odoc-content"><h3 id="type-definitions"><a href="#type-definitions" class="anchor"></a>Type definitions</h3><div class="odoc-spec"><div class="spec type anchored" id="type-term"><a href="#type-term" class="anchor"></a><code><span><span class="keyword">type</span> term</span><span> = <a href="../Term/index.html#type-t">Term.t</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-location"><a href="#type-location" class="anchor"></a><code><span><span class="keyword">type</span> location</span><span> = <a href="../Loc/index.html#type-t">Loc.t</a></span></code></div><div class="spec-doc"><p>Type aliases for readability.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-abstract"><a href="#type-abstract" class="anchor"></a><code><span><span class="keyword">type</span> abstract</span><span> = </span><span>{</span></code><ol><li id="type-abstract.id" class="def record field anchored"><a href="#type-abstract.id" class="anchor"></a><code><span>id : <a href="../Id/index.html#type-t">Id.t</a>;</span></code></li><li id="type-abstract.ty" class="def record field anchored"><a href="#type-abstract.ty" class="anchor"></a><code><span>ty : <a href="#type-term">term</a>;</span></code></li><li id="type-abstract.loc" class="def record field anchored"><a href="#type-abstract.loc" class="anchor"></a><code><span>loc : <a href="#type-location">location</a>;</span></code></li><li id="type-abstract.attrs" class="def record field anchored"><a href="#type-abstract.attrs" class="anchor"></a><code><span>attrs : <span><a href="#type-term">term</a> list</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>The type for abstract type definitions.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-inductive"><a href="#type-inductive" class="anchor"></a><code><span><span class="keyword">type</span> inductive</span><span> = </span><span>{</span></code><ol><li id="type-inductive.id" class="def record field anchored"><a href="#type-inductive.id" class="anchor"></a><code><span>id : <a href="../Id/index.html#type-t">Id.t</a>;</span></code></li><li id="type-inductive.vars" class="def record field anchored"><a href="#type-inductive.vars" class="anchor"></a><code><span>vars : <span><a href="#type-term">term</a> list</span>;</span></code></li><li id="type-inductive.cstrs" class="def record field anchored"><a href="#type-inductive.cstrs" class="anchor"></a><code><span>cstrs : <span><span>(<a href="../Id/index.html#type-t">Id.t</a> * <span><a href="#type-term">term</a> list</span>)</span> list</span>;</span></code></li><li id="type-inductive.loc" class="def record field anchored"><a href="#type-inductive.loc" class="anchor"></a><code><span>loc : <a href="#type-location">location</a>;</span></code></li><li id="type-inductive.attrs" class="def record field anchored"><a href="#type-inductive.attrs" class="anchor"></a><code><span>attrs : <span><a href="#type-term">term</a> list</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>The type for inductive type declarations. The &quot;vars&quot; field if used to store polymorphic variables of the inductive type. For instance, a polymorphic type for lists would have a single variable &quot;a&quot;. The constructors each have a name and a list of concrete arguments types (they all implicitly take as many type arguments as there are variables). So, for instance, the polymorphic list type would have two constructors:</p><ul><li><code>&quot;Nil&quot;, []</code></li><li><code>&quot;Cons&quot;, [var &quot;a&quot;]</code></li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-record"><a href="#type-record" class="anchor"></a><code><span><span class="keyword">type</span> record</span><span> = </span><span>{</span></code><ol><li id="type-record.id" class="def record field anchored"><a href="#type-record.id" class="anchor"></a><code><span>id : <a href="../Id/index.html#type-t">Id.t</a>;</span></code></li><li id="type-record.vars" class="def record field anchored"><a href="#type-record.vars" class="anchor"></a><code><span>vars : <span><a href="#type-term">term</a> list</span>;</span></code></li><li id="type-record.fields" class="def record field anchored"><a href="#type-record.fields" class="anchor"></a><code><span>fields : <span><span>(<a href="../Id/index.html#type-t">Id.t</a> * <a href="#type-term">term</a>)</span> list</span>;</span></code></li><li id="type-record.loc" class="def record field anchored"><a href="#type-record.loc" class="anchor"></a><code><span>loc : <a href="#type-location">location</a>;</span></code></li><li id="type-record.attrs" class="def record field anchored"><a href="#type-record.attrs" class="anchor"></a><code><span>attrs : <span><a href="#type-term">term</a> list</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>The type of record definitions.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-decl"><a href="#type-decl" class="anchor"></a><code><span><span class="keyword">type</span> decl</span><span> = </span></code><ol><li id="type-decl.Abstract" class="def variant constructor anchored"><a href="#type-decl.Abstract" class="anchor"></a><code><span>| </span><span><span class="constructor">Abstract</span> <span class="keyword">of</span> <a href="#type-abstract">abstract</a></span></code></li><li id="type-decl.Record" class="def variant constructor anchored"><a href="#type-decl.Record" class="anchor"></a><code><span>| </span><span><span class="constructor">Record</span> <span class="keyword">of</span> <a href="#type-record">record</a></span></code></li><li id="type-decl.Inductive" class="def variant constructor anchored"><a href="#type-decl.Inductive" class="anchor"></a><code><span>| </span><span><span class="constructor">Inductive</span> <span class="keyword">of</span> <a href="#type-inductive">inductive</a></span></code></li></ol></div><div class="spec-doc"><p>Type definitions, type declarations, and term declaration.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-def"><a href="#type-def" class="anchor"></a><code><span><span class="keyword">type</span> def</span><span> = </span><span>{</span></code><ol><li id="type-def.id" class="def record field anchored"><a href="#type-def.id" class="anchor"></a><code><span>id : <a href="../Id/index.html#type-t">Id.t</a>;</span></code></li><li id="type-def.vars" class="def record field anchored"><a href="#type-def.vars" class="anchor"></a><code><span>vars : <span><a href="#type-term">term</a> list</span>;</span></code></li><li id="type-def.params" class="def record field anchored"><a href="#type-def.params" class="anchor"></a><code><span>params : <span><a href="#type-term">term</a> list</span>;</span></code></li><li id="type-def.ret_ty" class="def record field anchored"><a href="#type-def.ret_ty" class="anchor"></a><code><span>ret_ty : <a href="#type-term">term</a>;</span></code></li><li id="type-def.body" class="def record field anchored"><a href="#type-def.body" class="anchor"></a><code><span>body : <a href="#type-term">term</a>;</span></code></li><li id="type-def.loc" class="def record field anchored"><a href="#type-def.loc" class="anchor"></a><code><span>loc : <a href="#type-location">location</a>;</span></code></li><li id="type-def.attrs" class="def record field anchored"><a href="#type-def.attrs" class="anchor"></a><code><span>attrs : <span><a href="#type-term">term</a> list</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Term definition.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-group"><a href="#type-group" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a group</span></span><span> = </span><span>{</span></code><ol><li id="type-group.contents" class="def record field anchored"><a href="#type-group.contents" class="anchor"></a><code><span>contents : <span><span class="type-var">'a</span> list</span>;</span></code></li><li id="type-group.recursive" class="def record field anchored"><a href="#type-group.recursive" class="anchor"></a><code><span>recursive : bool;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Groups of declarations or definitions, which can be recursive or not.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-defs"><a href="#type-defs" class="anchor"></a><code><span><span class="keyword">type</span> defs</span><span> = <span><a href="#type-def">def</a> <a href="#type-group">group</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-decls"><a href="#type-decls" class="anchor"></a><code><span><span class="keyword">type</span> decls</span><span> = <span><a href="#type-decl">decl</a> <a href="#type-group">group</a></span></span></code></div><div class="spec-doc"><p>Convenient aliases</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-descr"><a href="#type-descr" class="anchor"></a><code><span><span class="keyword">type</span> descr</span><span> = </span></code><ol><li id="type-descr.Pack" class="def variant constructor anchored"><a href="#type-descr.Pack" class="anchor"></a><code><span>| </span><span><span class="constructor">Pack</span> <span class="keyword">of</span> <span><a href="#type-t">t</a> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Pack a list of statements that have a semantic meaning (for instance a list of mutually recursive inductive definitions).</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Pop" class="def variant constructor anchored"><a href="#type-descr.Pop" class="anchor"></a><code><span>| </span><span><span class="constructor">Pop</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Pop the stack of assertions as many times as specified.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Push" class="def variant constructor anchored"><a href="#type-descr.Push" class="anchor"></a><code><span>| </span><span><span class="constructor">Push</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Push as many new levels on the stack of assertions as specified.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Reset_assertions" class="def variant constructor anchored"><a href="#type-descr.Reset_assertions" class="anchor"></a><code><span>| </span><span><span class="constructor">Reset_assertions</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Reset all assertions.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Plain" class="def variant constructor anchored"><a href="#type-descr.Plain" class="anchor"></a><code><span>| </span><span><span class="constructor">Plain</span> <span class="keyword">of</span> <a href="#type-term">term</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A plain statement containing a term with no defined semantics.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Prove" class="def variant constructor anchored"><a href="#type-descr.Prove" class="anchor"></a><code><span>| </span><span><span class="constructor">Prove</span> <span class="keyword">of</span> <span><a href="#type-term">term</a> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Try and prove the current sequent, under some local assumptions.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Clause" class="def variant constructor anchored"><a href="#type-descr.Clause" class="anchor"></a><code><span>| </span><span><span class="constructor">Clause</span> <span class="keyword">of</span> <span><a href="#type-term">term</a> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Add the given clause on the left side of the current sequent.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Antecedent" class="def variant constructor anchored"><a href="#type-descr.Antecedent" class="anchor"></a><code><span>| </span><span><span class="constructor">Antecedent</span> <span class="keyword">of</span> <a href="#type-term">term</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Add the given proposition on the left of the current sequent.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Consequent" class="def variant constructor anchored"><a href="#type-descr.Consequent" class="anchor"></a><code><span>| </span><span><span class="constructor">Consequent</span> <span class="keyword">of</span> <a href="#type-term">term</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Add the given proposition on the right of the current sequent.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Include" class="def variant constructor anchored"><a href="#type-descr.Include" class="anchor"></a><code><span>| </span><span><span class="constructor">Include</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>File include, qualified include paths, if any, are stored in the attribute.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Set_logic" class="def variant constructor anchored"><a href="#type-descr.Set_logic" class="anchor"></a><code><span>| </span><span><span class="constructor">Set_logic</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Set the logic to use for proving.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Get_info" class="def variant constructor anchored"><a href="#type-descr.Get_info" class="anchor"></a><code><span>| </span><span><span class="constructor">Get_info</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Get required information.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Set_info" class="def variant constructor anchored"><a href="#type-descr.Set_info" class="anchor"></a><code><span>| </span><span><span class="constructor">Set_info</span> <span class="keyword">of</span> <a href="#type-term">term</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Set the information value.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Get_option" class="def variant constructor anchored"><a href="#type-descr.Get_option" class="anchor"></a><code><span>| </span><span><span class="constructor">Get_option</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Get the required option value.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Set_option" class="def variant constructor anchored"><a href="#type-descr.Set_option" class="anchor"></a><code><span>| </span><span><span class="constructor">Set_option</span> <span class="keyword">of</span> <a href="#type-term">term</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Set the option value.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Defs" class="def variant constructor anchored"><a href="#type-descr.Defs" class="anchor"></a><code><span>| </span><span><span class="constructor">Defs</span> <span class="keyword">of</span> <span><a href="#type-def">def</a> <a href="#type-group">group</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Symbol definition, i.e the symbol is equal to the given term.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Decls" class="def variant constructor anchored"><a href="#type-descr.Decls" class="anchor"></a><code><span>| </span><span><span class="constructor">Decls</span> <span class="keyword">of</span> <span><a href="#type-decl">decl</a> <a href="#type-group">group</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A list of potentially recursive type definitions.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Get_proof" class="def variant constructor anchored"><a href="#type-descr.Get_proof" class="anchor"></a><code><span>| </span><span><span class="constructor">Get_proof</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Get the proof of the last sequent (if it was proved).</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Get_unsat_core" class="def variant constructor anchored"><a href="#type-descr.Get_unsat_core" class="anchor"></a><code><span>| </span><span><span class="constructor">Get_unsat_core</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Get the unsat core of the last sequent.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Get_unsat_assumptions" class="def variant constructor anchored"><a href="#type-descr.Get_unsat_assumptions" class="anchor"></a><code><span>| </span><span><span class="constructor">Get_unsat_assumptions</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Get the local assumptions in the unsat core of the last sequent.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Get_model" class="def variant constructor anchored"><a href="#type-descr.Get_model" class="anchor"></a><code><span>| </span><span><span class="constructor">Get_model</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Get the current model of the prover.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Get_value" class="def variant constructor anchored"><a href="#type-descr.Get_value" class="anchor"></a><code><span>| </span><span><span class="constructor">Get_value</span> <span class="keyword">of</span> <span><a href="#type-term">term</a> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Get the value of some terms in the current model of the prover.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Get_assignment" class="def variant constructor anchored"><a href="#type-descr.Get_assignment" class="anchor"></a><code><span>| </span><span><span class="constructor">Get_assignment</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Get the assignment of labbeled formulas (see smtlib manual).</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Get_assertions" class="def variant constructor anchored"><a href="#type-descr.Get_assertions" class="anchor"></a><code><span>| </span><span><span class="constructor">Get_assertions</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Get the current set of assertions.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Echo" class="def variant constructor anchored"><a href="#type-descr.Echo" class="anchor"></a><code><span>| </span><span><span class="constructor">Echo</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Prints the string.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Reset" class="def variant constructor anchored"><a href="#type-descr.Reset" class="anchor"></a><code><span>| </span><span><span class="constructor">Reset</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Full reset of the prover to its initial state.</p><span class="comment-delim">*)</span></div></li><li id="type-descr.Exit" class="def variant constructor anchored"><a href="#type-descr.Exit" class="anchor"></a><code><span>| </span><span><span class="constructor">Exit</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Exit the interactive loop.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">and</span> t</span><span> = </span><span>{</span></code><ol><li id="type-t.id" class="def record field anchored"><a href="#type-t.id" class="anchor"></a><code><span>id : <span><a href="../Id/index.html#type-t">Id.t</a> option</span>;</span></code></li><li id="type-t.descr" class="def record field anchored"><a href="#type-t.descr" class="anchor"></a><code><span>descr : <a href="#type-descr">descr</a>;</span></code></li><li id="type-t.attrs" class="def record field anchored"><a href="#type-t.attrs" class="anchor"></a><code><span>attrs : <span><a href="#type-term">term</a> list</span>;</span></code></li><li id="type-t.loc" class="def record field anchored"><a href="#type-t.loc" class="anchor"></a><code><span>loc : <a href="#type-location">location</a>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>The type of statements. Statements have optional location and attributes (or annotations). Additionally the each have a name (which mainly comes from tptp statements), that can very well be the empty string (and so it is likely <b>not</b> unique).</p></div></div><h3 id="implemented-interfaces"><a href="#implemented-interfaces" class="anchor"></a>Implemented interfaces</h3><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../Dolmen_intf/Stmt/module-type-Logic/index.html">Dolmen_intf.Stmt.Logic</a>
  <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../Dolmen_intf/Stmt/module-type-Logic/index.html#type-t">t</a> := <a href="#type-t">t</a></span>
   <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../../Dolmen_intf/Stmt/module-type-Logic/index.html#type-id">id</a> := <a href="../Id/index.html#type-t">Id.t</a></span>
   <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../../Dolmen_intf/Stmt/module-type-Logic/index.html#type-term">term</a> := <a href="#type-term">term</a></span>
   <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../../Dolmen_intf/Stmt/module-type-Logic/index.html#type-location">location</a> := <a href="#type-location">location</a></span></span></code></summary><h3 id="optional-infos-for-statements"><a href="#optional-infos-for-statements" class="anchor"></a>Optional infos for statements</h3><div class="odoc-spec"><div class="spec value anchored" id="val-annot"><a href="#val-annot" class="anchor"></a><code><span><span class="keyword">val</span> annot : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-term">term</a></span></code></div><div class="spec-doc"><p>Constructors for annotations. Annotations are mainly used in TPTP.</p></div></div><h3 id="generic-statements"><a href="#generic-statements" class="anchor"></a>Generic statements</h3><div class="odoc-spec"><div class="spec value anchored" id="val-import"><a href="#val-import" class="anchor"></a><code><span><span class="keyword">val</span> import : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Import directive. Same as <code>include_</code> but without filtering on the statements to import.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-include_"><a href="#val-include_" class="anchor"></a><code><span><span class="keyword">val</span> include_ : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Id/index.html#type-t">Id.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Include directive. <code>include file l</code> means to include in the current scope the directives from file <code>file</code> that appear in <code>l</code>. If <code>l</code> is the empty list, all directives should be imported.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-defs"><a href="#val-defs" class="anchor"></a><code><span><span class="keyword">val</span> defs : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?attrs:<span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Pack a list of mutually recursive definitions into a single statement.</p></div></div><h3 id="alt-ergo-statements"><a href="#alt-ergo-statements" class="anchor"></a>Alt-ergo Statements</h3><div class="odoc-spec"><div class="spec value anchored" id="val-logic"><a href="#val-logic" class="anchor"></a><code><span><span class="keyword">val</span> logic : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>ac:bool <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Id/index.html#type-t">Id.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Functions type definition. Allows to specify whether a list of symbol is ac or not</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-record_type"><a href="#val-record_type" class="anchor"></a><code><span><span class="keyword">val</span> record_type : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="../Id/index.html#type-t">Id.t</a> * <a href="#type-term">term</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Declares a new record type, with first a list of type variables, and then the list of the record fields.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-abstract_type"><a href="#val-abstract_type" class="anchor"></a><code><span><span class="keyword">val</span> abstract_type : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Declare a new abstract type, quantified over the given list of type variables.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-algebraic_type"><a href="#val-algebraic_type" class="anchor"></a><code><span><span class="keyword">val</span> algebraic_type : 
  <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../Id/index.html#type-t">Id.t</a> * <span><a href="#type-term">term</a> list</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Defines a new algebraic datatype, quantified over the lsit of type variables, and with a list of cases each containing a constructor id and a list of fields.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rec_types"><a href="#val-rec_types" class="anchor"></a><code><span><span class="keyword">val</span> rec_types : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Pack together a list of mutually recursive type definitions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pred_def"><a href="#val-pred_def" class="anchor"></a><code><span><span class="keyword">val</span> pred_def : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Symbol definition. <code>pred_def p vars args body</code> means that &quot;p(args) = (body : bool)&quot;, i.e <code>p</code> is a predicate symbol with arguments <code>args</code>, and which returns the value <code>body</code> which is of type <code>bool</code>. The predicate can also be a top-level predicate in which case it doesn't have arguments and it just returns the value of the body which means &quot;p = (body : bool)&quot;.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-axiom"><a href="#val-axiom" class="anchor"></a><code><span><span class="keyword">val</span> axiom : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a axiom.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-case_split"><a href="#val-case_split" class="anchor"></a><code><span><span class="keyword">val</span> case_split : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a case split.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-theory"><a href="#val-theory" class="anchor"></a><code><span><span class="keyword">val</span> theory : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a theory, extending another, with the given list of declarations.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rewriting"><a href="#val-rewriting" class="anchor"></a><code><span><span class="keyword">val</span> rewriting : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a set of rewriting rules.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prove_goal"><a href="#val-prove_goal" class="anchor"></a><code><span><span class="keyword">val</span> prove_goal : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Goal declaration.</p></div></div><h3 id="dimacs&amp;icnf-statements"><a href="#dimacs&amp;icnf-statements" class="anchor"></a>Dimacs&amp;iCNF Statements</h3><div class="odoc-spec"><div class="spec value anchored" id="val-p_cnf"><a href="#val-p_cnf" class="anchor"></a><code><span><span class="keyword">val</span> p_cnf : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Header of dimacs files. First argument is the number of variables, second is the number of clauses.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-p_inccnf"><a href="#val-p_inccnf" class="anchor"></a><code><span><span class="keyword">val</span> p_inccnf : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Header of iCNF files.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-clause"><a href="#val-clause" class="anchor"></a><code><span><span class="keyword">val</span> clause : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Add to the current set of assertions the given list of terms as a clause.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assumption"><a href="#val-assumption" class="anchor"></a><code><span><span class="keyword">val</span> assumption : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Solve the current set of assertions, with the given assumptions.</p></div></div><h3 id="smtlib-statements"><a href="#smtlib-statements" class="anchor"></a>Smtlib statements</h3><div class="odoc-spec"><div class="spec value anchored" id="val-pop"><a href="#val-pop" class="anchor"></a><code><span><span class="keyword">val</span> pop : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-push"><a href="#val-push" class="anchor"></a><code><span><span class="keyword">val</span> push : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Directives for manipulating the set of assertions. Push directives creates backtrack point that can be reached using Pop directives.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-reset_assertions"><a href="#val-reset_assertions" class="anchor"></a><code><span><span class="keyword">val</span> reset_assertions : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Reset all assertions that hase been pushed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assert_"><a href="#val-assert_" class="anchor"></a><code><span><span class="keyword">val</span> assert_ : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Add an assertion to the current set of assertions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-check_sat"><a href="#val-check_sat" class="anchor"></a><code><span><span class="keyword">val</span> check_sat : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Directive that instructs the prover to solve the current set of assertions, undr some local assumptions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_logic"><a href="#val-set_logic" class="anchor"></a><code><span><span class="keyword">val</span> set_logic : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Set the logic to be used for solving.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_info"><a href="#val-get_info" class="anchor"></a><code><span><span class="keyword">val</span> get_info : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_info"><a href="#val-set_info" class="anchor"></a><code><span><span class="keyword">val</span> set_info : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Getter and setter for various informations (see smtlib manual).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_option"><a href="#val-get_option" class="anchor"></a><code><span><span class="keyword">val</span> get_option : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_option"><a href="#val-set_option" class="anchor"></a><code><span><span class="keyword">val</span> set_option : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Getter and setter for prover options (see smtlib manual).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-type_decl"><a href="#val-type_decl" class="anchor"></a><code><span><span class="keyword">val</span> type_decl : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Type declaration. <code>type_decl s n</code> declare <code>s</code> as a type constructor with arity <code>n</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-type_def"><a href="#val-type_def" class="anchor"></a><code><span><span class="keyword">val</span> type_def : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Id/index.html#type-t">Id.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Type definition. <code>type_def f args body</code> declare that <code>f(args) = body</code>, i.e any occurence of &quot;f(l)&quot; should be replaced by <code>body</code> where the &quot;args&quot; have been substituted by their corresponding value in <code>l</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-datatypes"><a href="#val-datatypes" class="anchor"></a><code><span><span class="keyword">val</span> datatypes : 
  <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../Id/index.html#type-t">Id.t</a> * <span><a href="#type-term">term</a> list</span> * <span><span>(<a href="../Id/index.html#type-t">Id.t</a> * <span><a href="#type-term">term</a> list</span>)</span> list</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Inductive type definitions. TODO: some more documentation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fun_decl"><a href="#val-fun_decl" class="anchor"></a><code><span><span class="keyword">val</span> fun_decl : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Symbol declaration. <code>fun_decl f vars args ret</code> defines <code>f</code> as a function which takes arguments of type as described in <code>args</code> and which returns a value of type <code>ret</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fun_def"><a href="#val-fun_def" class="anchor"></a><code><span><span class="keyword">val</span> fun_def : 
  <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Symbol definition. <code>fun_def f vars args ret body</code> means that &quot;f(args) = (body : ret)&quot;, i.e f is a function symbol with arguments <code>args</code>, and which returns the value <code>body</code> which is of type <code>ret</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-funs_def_rec"><a href="#val-funs_def_rec" class="anchor"></a><code><span><span class="keyword">val</span> funs_def_rec : 
  <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../Id/index.html#type-t">Id.t</a> * <span><a href="#type-term">term</a> list</span> * <span><a href="#type-term">term</a> list</span> * <a href="#type-term">term</a> * <a href="#type-term">term</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Define a list of mutually recursive functions. Each function has the same definition as in <code>fun_def</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_proof"><a href="#val-get_proof" class="anchor"></a><code><span><span class="keyword">val</span> get_proof : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>If the last call to <code>check_sat</code> returned UNSAT, then instruct the prover to return the proof of unsat.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_unsat_core"><a href="#val-get_unsat_core" class="anchor"></a><code><span><span class="keyword">val</span> get_unsat_core : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>If the last call to <code>check_sat</code> returned UNSAT, then instruct the prover to return the unsat core of the unsatisfiability proof, i.e the smallest set of assertions needed to prove <code>false</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_unsat_assumptions"><a href="#val-get_unsat_assumptions" class="anchor"></a><code><span><span class="keyword">val</span> get_unsat_assumptions : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>If the last call to <code>check_sat</code> returned UNSAT, then instruct the prover to return a subset of the local assumptions that is sufficient to deduce UNSAT.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_model"><a href="#val-get_model" class="anchor"></a><code><span><span class="keyword">val</span> get_model : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>If the last call to <code>check_sat</code> returned SAT, then return the associated model.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_value"><a href="#val-get_value" class="anchor"></a><code><span><span class="keyword">val</span> get_value : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Instructs the prover to return the values of the given closed quantifier-free terms.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_assignment"><a href="#val-get_assignment" class="anchor"></a><code><span><span class="keyword">val</span> get_assignment : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Instructs the prover to return truth assignemnt for labelled formulas (see smtlib manual for more information).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_assertions"><a href="#val-get_assertions" class="anchor"></a><code><span><span class="keyword">val</span> get_assertions : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Instructs the prover to print all current assertions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-echo"><a href="#val-echo" class="anchor"></a><code><span><span class="keyword">val</span> echo : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Print the given sting.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-reset"><a href="#val-reset" class="anchor"></a><code><span><span class="keyword">val</span> reset : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Full reset of the prover state.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exit"><a href="#val-exit" class="anchor"></a><code><span><span class="keyword">val</span> exit : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Exit directive (used in interactive mode).</p></div></div><h3 id="tptp-statements"><a href="#tptp-statements" class="anchor"></a>TPTP Statements</h3><div class="odoc-spec"><div class="spec value anchored" id="val-tpi"><a href="#val-tpi" class="anchor"></a><code><span><span class="keyword">val</span> tpi : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?annot:<a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-thf"><a href="#val-thf" class="anchor"></a><code><span><span class="keyword">val</span> thf : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?annot:<a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tff"><a href="#val-tff" class="anchor"></a><code><span><span class="keyword">val</span> tff : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?annot:<a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fof"><a href="#val-fof" class="anchor"></a><code><span><span class="keyword">val</span> fof : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?annot:<a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cnf"><a href="#val-cnf" class="anchor"></a><code><span><span class="keyword">val</span> cnf : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?annot:<a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>TPTP directives. <code>tptp name role t</code> instructs the prover to register a new directive with the given name, role and term. Current tptp roles are:</p><ul><li><code>&quot;axiom&quot;, &quot;hypothesis&quot;, &quot;definition&quot;, &quot;lemma&quot;, &quot;theorem&quot;</code> acts as new assertions/declartions</li><li><p><code>&quot;assumption&quot;, &quot;conjecture&quot;</code> are proposition that need to be proved, and then can be used to prove other propositions. They are equivalent to the following sequence of smtlib statements:</p><ul><li><code>push 1</code></li><li><code>assert (not t)</code></li><li><code>check_sat</code></li><li><code>pop 1</code></li><li><code>assert t</code></li></ul></li><li><code>&quot;negated_conjecture&quot;</code> is the same as <code>&quot;conjecture&quot;</code>, but the given proposition is false (i.e its negation is the proposition to prove).</li><li><code>&quot;type&quot;</code> declares a new symbol and its type</li><li><code>&quot;plain&quot;, &quot;unknown&quot;, &quot;fi_domain&quot;, &quot;fi_functors&quot;, &quot;fi_predicates&quot;</code> are valid roles with no specified semantics</li><li>any other role is an error</li></ul></div></div><h3 id="zipperposition-statements"><a href="#zipperposition-statements" class="anchor"></a>Zipperposition statements</h3><div class="odoc-spec"><div class="spec value anchored" id="val-data"><a href="#val-data" class="anchor"></a><code><span><span class="keyword">val</span> data : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?attrs:<span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Packs a list of mutually recursive inductive type declarations into a single statement.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rewrite"><a href="#val-rewrite" class="anchor"></a><code><span><span class="keyword">val</span> rewrite : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?attrs:<span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Declare a rewrite rule, i.e a universally quantified equality or equivalence that can be oriented according to a specific ordering.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-goal"><a href="#val-goal" class="anchor"></a><code><span><span class="keyword">val</span> goal : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?attrs:<span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>The goal, i.e the propositional formula to prove.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assume"><a href="#val-assume" class="anchor"></a><code><span><span class="keyword">val</span> assume : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?attrs:<span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Adds an hypothesis.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lemma"><a href="#val-lemma" class="anchor"></a><code><span><span class="keyword">val</span> lemma : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?attrs:<span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Lemmas.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-decl"><a href="#val-decl" class="anchor"></a><code><span><span class="keyword">val</span> decl : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?attrs:<span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Symbol declaration. <code>decl name ty</code> declares a new symbol <code>name</code> with type <code>ty</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-definition"><a href="#val-definition" class="anchor"></a><code><span><span class="keyword">val</span> definition : 
  <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?attrs:<span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Symbol definition. <code>def name ty term</code> defines a new symbol <code>name</code> of type <code>ty</code> which is equal to <code>term</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-inductive"><a href="#val-inductive" class="anchor"></a><code><span><span class="keyword">val</span> inductive : 
  <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?attrs:<span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../Id/index.html#type-t">Id.t</a> * <span><a href="#type-term">term</a> list</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Inductive type definitions. <code>inductive name vars l</code> defines an inductive type <code>name</code>, with polymorphic variables <code>vars</code>, and with a list of inductive constructors <code>l</code>.</p></div></div></details></div><h3 id="additional-functions"><a href="#additional-functions" class="anchor"></a>Additional functions</h3><div class="odoc-spec"><div class="spec value anchored" id="val-mk_decls"><a href="#val-mk_decls" class="anchor"></a><code><span><span class="keyword">val</span> mk_decls : 
  <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?attrs:<span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>recursive:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-decl">decl</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a group of declarations</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mk_defs"><a href="#val-mk_defs" class="anchor"></a><code><span><span class="keyword">val</span> mk_defs : 
  <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?attrs:<span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>recursive:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-def">def</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a group of declarations</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-def"><a href="#val-def" class="anchor"></a><code><span><span class="keyword">val</span> def : 
  <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>vars:<span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>params:<span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-def">def</a></span></code></div><div class="spec-doc"><p>Create a single definition.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-group"><a href="#val-group" class="anchor"></a><code><span><span class="keyword">val</span> group : <span>recursive:bool <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-group">group</a></span></span></code></div><div class="spec-doc"><p>Make a group 'usually of declarations/definitions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prove"><a href="#val-prove" class="anchor"></a><code><span><span class="keyword">val</span> prove : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Emit a <code>Prove</code> statement.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pack"><a href="#val-pack" class="anchor"></a><code><span><span class="keyword">val</span> pack : <span>?id:<a href="../Id/index.html#type-t">Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?attrs:<span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Pack a list of statements into a single one.</p></div></div><h3 id="printing-functions"><a href="#printing-functions" class="anchor"></a>Printing functions</h3><div class="odoc-spec"><div class="spec value anchored" id="val-print"><a href="#val-print" class="anchor"></a><code><span><span class="keyword">val</span> print : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Printing functions for statements.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_decl"><a href="#val-print_decl" class="anchor"></a><code><span><span class="keyword">val</span> print_decl : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-decl">decl</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_def"><a href="#val-print_def" class="anchor"></a><code><span><span class="keyword">val</span> print_def : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-def">def</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_group"><a href="#val-print_group" class="anchor"></a><code><span><span class="keyword">val</span> print_group : 
  <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-group">group</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div></div></body></html>