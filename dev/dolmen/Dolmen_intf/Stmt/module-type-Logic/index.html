<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Logic (dolmen.Dolmen_intf.Stmt.Logic)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">dolmen</a> &#x00BB; <a href="../../index.html">Dolmen_intf</a> &#x00BB; <a href="../index.html">Stmt</a> &#x00BB; Logic</nav><header class="odoc-preamble"><h1>Module type <code><span>Stmt.Logic</span></code></h1><p>Signature used by the Logic class, which parses languages such as tptp, smtlib, etc... Statements of dirrent languages currently have a lot less in common than terms, so this interface looks a lot more like a patchwork of different logical framework directives than it should.</p></header><nav class="odoc-toc"><ul><li><a href="#optional-infos-for-statements">Optional infos for statements</a></li><li><a href="#generic-statements">Generic statements</a></li><li><a href="#alt-ergo-statements">Alt-ergo Statements</a></li><li><a href="#dimacs&amp;icnf-statements">Dimacs&amp;iCNF Statements</a></li><li><a href="#smtlib-statements">Smtlib statements</a></li><li><a href="#tptp-statements">TPTP Statements</a></li><li><a href="#zipperposition-statements">Zipperposition statements</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The type of statements.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-id" class="anchored"><a href="#type-id" class="anchor"></a><code><span><span class="keyword">type</span> id</span></code></div><div class="spec-doc"><p>The type of identifiers.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-term" class="anchored"><a href="#type-term" class="anchor"></a><code><span><span class="keyword">type</span> term</span></code></div><div class="spec-doc"><p>The type of terms used in statements.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-location" class="anchored"><a href="#type-location" class="anchor"></a><code><span><span class="keyword">type</span> location</span></code></div><div class="spec-doc"><p>The type of locations attached to statements.</p></div></div><h3 id="optional-infos-for-statements"><a href="#optional-infos-for-statements" class="anchor"></a>Optional infos for statements</h3><div class="odoc-spec"><div class="spec value" id="val-annot" class="anchored"><a href="#val-annot" class="anchor"></a><code><span><span class="keyword">val</span> annot : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-term">term</a></span></code></div><div class="spec-doc"><p>Constructors for annotations. Annotations are mainly used in TPTP.</p></div></div><h3 id="generic-statements"><a href="#generic-statements" class="anchor"></a>Generic statements</h3><div class="odoc-spec"><div class="spec value" id="val-import" class="anchored"><a href="#val-import" class="anchor"></a><code><span><span class="keyword">val</span> import : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Import directive. Same as <code>include_</code> but without filtering on the statements to import.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-include_" class="anchored"><a href="#val-include_" class="anchor"></a><code><span><span class="keyword">val</span> include_ : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-id">id</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Inlcude directive. <code>include file l</code> means to include in the current scope the directives from file <code>file</code> that appear in <code>l</code>. If <code>l</code> is the empty list, all directives should be imported.</p></div></div><h3 id="alt-ergo-statements"><a href="#alt-ergo-statements" class="anchor"></a>Alt-ergo Statements</h3><div class="odoc-spec"><div class="spec value" id="val-logic" class="anchored"><a href="#val-logic" class="anchor"></a><code><span><span class="keyword">val</span> logic : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>ac:bool <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-id">id</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Functions type definition. Allows to specify whether a list of symbol is ac or not</p></div></div><div class="odoc-spec"><div class="spec value" id="val-record_type" class="anchored"><a href="#val-record_type" class="anchor"></a><code><span><span class="keyword">val</span> record_type : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="#type-id">id</a> * <a href="#type-term">term</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Declares a new record type, with first a list of type variables, and then the list of the record fields.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-abstract_type" class="anchored"><a href="#val-abstract_type" class="anchor"></a><code><span><span class="keyword">val</span> abstract_type : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Declare a new abstract type, quantified over the given list of type variables.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-algebraic_type" class="anchored"><a href="#val-algebraic_type" class="anchor"></a><code><span><span class="keyword">val</span> algebraic_type : 
  <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-id">id</a> * <span><a href="#type-term">term</a> list</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Defines a new algebraic datatype, quantified over the lsit of type variables, and with a list of cases each containing a constructor id and a list of fields.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rec_types" class="anchored"><a href="#val-rec_types" class="anchor"></a><code><span><span class="keyword">val</span> rec_types : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Pack together a list of mutually recursive type definitions.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-axiom" class="anchored"><a href="#val-axiom" class="anchor"></a><code><span><span class="keyword">val</span> axiom : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a axiom.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-case_split" class="anchored"><a href="#val-case_split" class="anchor"></a><code><span><span class="keyword">val</span> case_split : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a case split.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-theory" class="anchored"><a href="#val-theory" class="anchor"></a><code><span><span class="keyword">val</span> theory : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a theory, extending another, with the given list of declarations.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rewriting" class="anchored"><a href="#val-rewriting" class="anchor"></a><code><span><span class="keyword">val</span> rewriting : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a set of rewriting rules.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-prove_goal" class="anchored"><a href="#val-prove_goal" class="anchor"></a><code><span><span class="keyword">val</span> prove_goal : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Goal declaration.</p></div></div><h3 id="dimacs&amp;icnf-statements"><a href="#dimacs&amp;icnf-statements" class="anchor"></a>Dimacs&amp;iCNF Statements</h3><div class="odoc-spec"><div class="spec value" id="val-p_cnf" class="anchored"><a href="#val-p_cnf" class="anchor"></a><code><span><span class="keyword">val</span> p_cnf : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Header of dimacs files. First argument is the number of variables, second is the number of clauses.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-p_inccnf" class="anchored"><a href="#val-p_inccnf" class="anchor"></a><code><span><span class="keyword">val</span> p_inccnf : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Header of iCNF files.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-clause" class="anchored"><a href="#val-clause" class="anchor"></a><code><span><span class="keyword">val</span> clause : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Add to the current set of assertions the given list of terms as a clause.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-assumption" class="anchored"><a href="#val-assumption" class="anchor"></a><code><span><span class="keyword">val</span> assumption : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Solve the current set of assertions, with the given assumptions.</p></div></div><h3 id="smtlib-statements"><a href="#smtlib-statements" class="anchor"></a>Smtlib statements</h3><div class="odoc-spec"><div class="spec value" id="val-pop" class="anchored"><a href="#val-pop" class="anchor"></a><code><span><span class="keyword">val</span> pop : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-push" class="anchored"><a href="#val-push" class="anchor"></a><code><span><span class="keyword">val</span> push : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Directives for manipulating the set of assertions. Push directives creates backtrack point that can be reached using Pop directives.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-reset_assertions" class="anchored"><a href="#val-reset_assertions" class="anchor"></a><code><span><span class="keyword">val</span> reset_assertions : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Reset all assertions that hase been pushed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-assert_" class="anchored"><a href="#val-assert_" class="anchor"></a><code><span><span class="keyword">val</span> assert_ : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Add an assertion to the current set of assertions.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-check_sat" class="anchored"><a href="#val-check_sat" class="anchor"></a><code><span><span class="keyword">val</span> check_sat : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Directive that instructs the prover to solve the current set of assertions, undr some local assumptions.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_logic" class="anchored"><a href="#val-set_logic" class="anchor"></a><code><span><span class="keyword">val</span> set_logic : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Set the logic to be used for solving.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_info" class="anchored"><a href="#val-get_info" class="anchor"></a><code><span><span class="keyword">val</span> get_info : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-set_info" class="anchored"><a href="#val-set_info" class="anchor"></a><code><span><span class="keyword">val</span> set_info : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Getter and setter for various informations (see smtlib manual).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_option" class="anchored"><a href="#val-get_option" class="anchor"></a><code><span><span class="keyword">val</span> get_option : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-set_option" class="anchored"><a href="#val-set_option" class="anchor"></a><code><span><span class="keyword">val</span> set_option : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Getter and setter for prover options (see smtlib manual).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-type_decl" class="anchored"><a href="#val-type_decl" class="anchor"></a><code><span><span class="keyword">val</span> type_decl : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Type declaration. <code>type_decl s n</code> declare <code>s</code> as a type constructor with arity <code>n</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-type_def" class="anchored"><a href="#val-type_def" class="anchor"></a><code><span><span class="keyword">val</span> type_def : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-id">id</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Type definition. <code>type_def f args body</code> declare that <code>f(args) = body</code>, i.e any occurence of &quot;f(l)&quot; should be replaced by <code>body</code> where the &quot;args&quot; have been substituted by their corresponding value in <code>l</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-datatypes" class="anchored"><a href="#val-datatypes" class="anchor"></a><code><span><span class="keyword">val</span> datatypes : 
  <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-id">id</a> * <span><a href="#type-term">term</a> list</span> * <span><span>(<a href="#type-id">id</a> * <span><a href="#type-term">term</a> list</span>)</span> list</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Inductive type definitions. TODO: some more documentation.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fun_decl" class="anchored"><a href="#val-fun_decl" class="anchor"></a><code><span><span class="keyword">val</span> fun_decl : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Symbol declaration. <code>fun_decl f vars args ret</code> defines <code>f</code> as a function which takes arguments of type as described in <code>args</code> and which returns a value of type <code>ret</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fun_def" class="anchored"><a href="#val-fun_def" class="anchor"></a><code><span><span class="keyword">val</span> fun_def : 
  <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Symbol definition. <code>fun_def f vars args ret body</code> means that &quot;f(args) = (body : ret)&quot;, i.e f is a function symbol with arguments <code>args</code>, and which returns the value <code>body</code> which is of type <code>ret</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pred_def" class="anchored"><a href="#val-pred_def" class="anchor"></a><code><span><span class="keyword">val</span> pred_def : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Symbol definition. <code>pred_def p vars args body</code> means that &quot;p(args) = (body : bool)&quot;, i.e <code>p</code> is a predicate symbol with arguments <code>args</code>, and which returns the value <code>body</code> which is of type <code>bool</code>. The predicate can also be a top-level predicate in which case it doesn't have arguments and it just returns the value of the body which means &quot;p = (body : bool)&quot;.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-funs_def_rec" class="anchored"><a href="#val-funs_def_rec" class="anchor"></a><code><span><span class="keyword">val</span> funs_def_rec : 
  <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-id">id</a> * <span><a href="#type-term">term</a> list</span> * <span><a href="#type-term">term</a> list</span> * <a href="#type-term">term</a> * <a href="#type-term">term</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Define a list of mutually recursive functions. Each functions has the same definition as in <code>fun_def</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_proof" class="anchored"><a href="#val-get_proof" class="anchor"></a><code><span><span class="keyword">val</span> get_proof : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>If the last call to <code>check_sat</code> returned UNSAT, then instruct the prover to return the proof of unsat.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_unsat_core" class="anchored"><a href="#val-get_unsat_core" class="anchor"></a><code><span><span class="keyword">val</span> get_unsat_core : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>If the last call to <code>check_sat</code> returned UNSAT, then instruct the prover to return the unsat core of the unsatisfiability proof, i.e the smallest set of assertions needed to prove <code>false</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_unsat_assumptions" class="anchored"><a href="#val-get_unsat_assumptions" class="anchor"></a><code><span><span class="keyword">val</span> get_unsat_assumptions : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>If the last call to <code>check_sat</code> returned UNSAT, then instruct the prover to return a subset of the local assumptions that is sufficient to deduce UNSAT.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_model" class="anchored"><a href="#val-get_model" class="anchor"></a><code><span><span class="keyword">val</span> get_model : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>If the last call to <code>check_sat</code> returned SAT, then return the associated model.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_value" class="anchored"><a href="#val-get_value" class="anchor"></a><code><span><span class="keyword">val</span> get_value : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Instructs the prover to return the values of the given closed quantifier-free terms.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_assignment" class="anchored"><a href="#val-get_assignment" class="anchor"></a><code><span><span class="keyword">val</span> get_assignment : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Instructs the prover to return truth assignemnt for labelled formulas (see smtlib manual for more information).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_assertions" class="anchored"><a href="#val-get_assertions" class="anchor"></a><code><span><span class="keyword">val</span> get_assertions : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Instructs the prover to print all current assertions.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-echo" class="anchored"><a href="#val-echo" class="anchor"></a><code><span><span class="keyword">val</span> echo : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Print the given sting.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-reset" class="anchored"><a href="#val-reset" class="anchor"></a><code><span><span class="keyword">val</span> reset : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Full reset of the prover state.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exit" class="anchored"><a href="#val-exit" class="anchor"></a><code><span><span class="keyword">val</span> exit : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Exit directive (used in interactive mode).</p></div></div><h3 id="tptp-statements"><a href="#tptp-statements" class="anchor"></a>TPTP Statements</h3><div class="odoc-spec"><div class="spec value" id="val-tpi" class="anchored"><a href="#val-tpi" class="anchor"></a><code><span><span class="keyword">val</span> tpi : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?annot:<a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-thf" class="anchored"><a href="#val-thf" class="anchor"></a><code><span><span class="keyword">val</span> thf : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?annot:<a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-tff" class="anchored"><a href="#val-tff" class="anchor"></a><code><span><span class="keyword">val</span> tff : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?annot:<a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-fof" class="anchored"><a href="#val-fof" class="anchor"></a><code><span><span class="keyword">val</span> fof : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?annot:<a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-cnf" class="anchored"><a href="#val-cnf" class="anchor"></a><code><span><span class="keyword">val</span> cnf : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?annot:<a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>TPTP directives. <code>tptp name role t</code> instructs the prover to register a new directive with the given name, role and term. Current tptp roles are:</p><ul><li><code>&quot;axiom&quot;, &quot;hypothesis&quot;, &quot;definition&quot;, &quot;lemma&quot;, &quot;theorem&quot;</code> acts as new assertions/declartions</li><li><p><code>&quot;assumption&quot;, &quot;conjecture&quot;</code> are proposition that need to be proved, and then can be used to prove other propositions. They are equivalent to the following sequence of smtlib statements:</p><ul><li><code>push 1</code></li><li><code>assert (not t)</code></li><li><code>check_sat</code></li><li><code>pop 1</code></li><li><code>assert t</code></li></ul></li><li><code>&quot;negated_conjecture&quot;</code> is the same as <code>&quot;conjecture&quot;</code>, but the given proposition is false (i.e its negation is the proposition to prove).</li><li><code>&quot;type&quot;</code> declares a new symbol and its type</li><li><code>&quot;plain&quot;, &quot;unknown&quot;, &quot;fi_domain&quot;, &quot;fi_functors&quot;, &quot;fi_predicates&quot;</code> are valid roles with no specified semantics</li><li>any other role is an error</li></ul></div></div><h3 id="zipperposition-statements"><a href="#zipperposition-statements" class="anchor"></a>Zipperposition statements</h3><div class="odoc-spec"><div class="spec value" id="val-data" class="anchored"><a href="#val-data" class="anchor"></a><code><span><span class="keyword">val</span> data : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?attrs:<span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Packs a list of mutually recursive inductive type declarations into a single statement.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-defs" class="anchored"><a href="#val-defs" class="anchor"></a><code><span><span class="keyword">val</span> defs : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?attrs:<span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Packs a list of mutually recursive definitions into a single statement.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rewrite" class="anchored"><a href="#val-rewrite" class="anchor"></a><code><span><span class="keyword">val</span> rewrite : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?attrs:<span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Declare a rewrite rule, i.e a universally quantified equality or equivalence that can be oriented according to a specific ordering.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-goal" class="anchored"><a href="#val-goal" class="anchor"></a><code><span><span class="keyword">val</span> goal : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?attrs:<span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>The goal, i.e the propositional formula to prove.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-assume" class="anchored"><a href="#val-assume" class="anchor"></a><code><span><span class="keyword">val</span> assume : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?attrs:<span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Adds an hypothesis.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lemma" class="anchored"><a href="#val-lemma" class="anchor"></a><code><span><span class="keyword">val</span> lemma : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?attrs:<span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Lemmas.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decl" class="anchored"><a href="#val-decl" class="anchor"></a><code><span><span class="keyword">val</span> decl : <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span>?attrs:<span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Symbol declaration. <code>decl name ty</code> declares a new symbol <code>name</code> with type <code>ty</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-definition" class="anchored"><a href="#val-definition" class="anchor"></a><code><span><span class="keyword">val</span> definition : 
  <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?attrs:<span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Symbol definition. <code>def name ty term</code> defines a new symbol <code>name</code> of type <code>ty</code> which is equal to <code>term</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-inductive" class="anchored"><a href="#val-inductive" class="anchor"></a><code><span><span class="keyword">val</span> inductive : 
  <span>?loc:<a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?attrs:<span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-id">id</a> * <span><a href="#type-term">term</a> list</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Inductive type definitions. <code>inductive name vars l</code> defines an inductive type <code>name</code>, with polymorphic variables <code>vars</code>, and with a list of inductive constructors <code>l</code>.</p></div></div></div></body></html>